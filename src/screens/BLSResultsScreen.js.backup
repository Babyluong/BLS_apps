// screens/BLSResultsScreen.js
import React, { useState, useEffect, useCallback } from "react";
import { 
  Text, View, TouchableOpacity, StyleSheet, ScrollView, 
  Alert, ActivityIndicator, Modal, RefreshControl, TextInput, Dimensions 
} from "react-native";
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { Platform } from 'react-native';
import { MaterialCommunityIcons } from "@expo/vector-icons";
import LuxuryShell from "../components/LuxuryShell";
import supabase from "../services/supabase";
import BLSResultsService from "../services/blsResultsService";
import CertificateScreen from "./CertificateScreen";
import { getUserCategory } from "../utils/scoreUtils";

const { width: screenWidth } = Dimensions.get('window');

export default function BLSResultsScreen({ onBack, onSignOut, onNavigate }) {
  console.log("=== BLSResultsScreen component rendering ===");
  console.log("ðŸ” CRITICAL: Component is rendering");
  
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState("");
  const [selectedResult, setSelectedResult] = useState(null);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [currentUser, setCurrentUser] = useState(null);
  const [selectedChecklist, setSelectedChecklist] = useState(null);
  const [showChecklistModal, setShowChecklistModal] = useState(false);
  const [showPretestModal, setShowPretestModal] = useState(false);
  const [selectedPretest, setSelectedPretest] = useState(null);
  const [pretestQuestions, setPretestQuestions] = useState([]);
  const [showPosttestModal, setShowPosttestModal] = useState(false);
  const [selectedPosttest, setSelectedPosttest] = useState(null);
  const [posttestQuestions, setPosttestQuestions] = useState([]);
  
  // New state for tabs and filtering
  const [activeTab, setActiveTab] = useState('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [dateFilter, setDateFilter] = useState('');
  const [dateFilterType, setDateFilterType] = useState('all'); // 'all', 'today', '7days', 'custom'
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [resultsPerPage, setResultsPerPage] = useState(20);
  const [currentPage, setCurrentPage] = useState(1);
  const [pretestStats, setPretestStats] = useState([]);
  const [posttestStats, setPosttestStats] = useState([]);
  const [allQuestions, setAllQuestions] = useState({ pretest: [], posttest: [] });
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [participantModalVisible, setParticipantModalVisible] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [filteredParticipants, setFilteredParticipants] = useState([]);
  const [showCertificate, setShowCertificate] = useState(false);
  const [certificateData, setCertificateData] = useState(null);
  const [customDateRange, setCustomDateRange] = useState({ start: null, end: null });
  const [showHighestScorersModal, setShowHighestScorersModal] = useState(false);
  const [highestScorersData, setHighestScorersData] = useState({ title: '', message: '', scorers: [] });

  // Helper function to get jawatan with better fallback logic
  const getJawatanWithFallback = (userData, participantName, user_id, participantIc = null) => {
    if (!userData) {
      console.warn(`âš ï¸ No user data found for user_id: ${user_id}, participant: ${participantName}`);
      
      // Try to find user by name and IC in the users table as fallback
      if (participantName && participantIc) {
        console.log(`ðŸ” Attempting to find user by name and IC: ${participantName}, ${participantIc}`);
        // This will be handled by the improved data fetching logic
        return 'N/A - User not found in users table';
      }
      
      return 'N/A - No user data';
    }
    
    const jawatan = userData.jawatan || '';
    if (!jawatan || jawatan.trim() === '') {
      console.warn(`âš ï¸ Empty jawatan for ${participantName} (${user_id}), source: ${userData.source}`);
      return 'N/A - No jawatan data';
    }
    
    console.log(`âœ… Jawatan found for ${participantName}:`, {
      user_id: user_id,
      jawatan: jawatan,
      source: userData.source
    });
    
    return jawatan;
  };

  // Load results data for all participants (admin) or current user only
  const loadResults = useCallback(async () => {
    console.log("=== loadResults function called ===");
    setLoading(true);
    setError("");
    try {
      // Get current user
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        setError("User not logged in.");
        setLoading(false);
        return;
      }
      
      setCurrentUser(user);
      
      // Check if user is admin
      const { data: userData } = await supabase
        .from("profiles")
        .select("id, role")
        .eq("id", user.id)
        .single();
      
      const isAdmin = userData?.role === 'admin';
      
      // Fetch quiz sessions (pretest and posttest)
      console.log("Starting to fetch quiz sessions...");
      let quizQuery = supabase
        .from("quiz_sessions")
        .select(`
          id,
          user_id,
          quiz_key,
          score,
          total_questions,
          percentage,
          status,
          participant_name,
          participant_ic,
          answers,
          created_at,
          updated_at
        `)
        .in("quiz_key", ["pretest", "posttest"])
        .eq("status", "submitted")
        .order("created_at", { ascending: false });

      if (!isAdmin) {
        quizQuery = quizQuery.eq("user_id", user.id);
      }

      const { data: quizSessions, error: quizError } = await quizQuery;
      if (quizError) {
        console.error("Error fetching quiz sessions:", quizError);
        console.error("Quiz query details:", {
          table: "quiz_sessions",
          select: "id,user_id,quiz_key,score,total_questions,percentage,status,participant_name,participant_ic,answers,created_at,updated_at",
          filters: {
            quiz_key: ["pretest", "posttest"],
            status: "submitted"
          },
          order: "created_at desc"
        });
      } else {
        console.log("Quiz sessions fetched successfully:", quizSessions?.length || 0, quizSessions);
      }

      // Fetch checklist results
      let checklistQuery = supabase
        .from("checklist_results")
        .select(`
          id,
          user_id,
          participant_name,
          participant_ic,
          checklist_type,
          score,
          total_items,
          status,
          checklist_details,
          comments,
          created_at
        `)
        .in("status", ["PASS", "FAIL"])
        .order("created_at", { ascending: false });

      if (!isAdmin) {
        checklistQuery = checklistQuery.eq("user_id", user.id);
      }

      const { data: checklistResults, error: checklistError } = await checklistQuery;
      if (checklistError) {
        console.error("Error fetching checklist results:", checklistError);
        console.error("Checklist query details:", {
          table: "checklist_results",
          select: "id,user_id,participant_name,participant_ic,checklist_type,score,total_items,status,checklist_details,comments,created_at",
          filters: {
            status: ["PASS", "FAIL"]
          },
          order: "created_at desc"
        });
      } else {
        console.log("Checklist results fetched successfully:", checklistResults?.length || 0, checklistResults);
      }

      // Create participant map to merge data
      const participantMap = new Map();

      // Fetch participant data from users table to get jawatan information
      const participantIds = new Set();
      if (quizSessions) {
        quizSessions.forEach(session => participantIds.add(session.user_id));
      }
      if (checklistResults) {
        checklistResults.forEach(result => participantIds.add(result.user_id));
      }

      // Fetch participant data from users table
      let participantData = {};
      if (participantIds.size > 0) {
        console.log("ðŸ” Fetching participant data for", participantIds.size, "users from users table");
        
        const { data: users, error: usersError } = await supabase
          .from("users")
          .select("id, jawatan, full_name, ic, tempat_bertugas, email")
          .in("id", Array.from(participantIds));
        
        if (usersError) {
          console.error("âŒ Error fetching from users table:", usersError);
        } else {
          console.log("âœ… Fetched", users?.length || 0, "users from users table");
          if (users) {
            users.forEach(user => {
              participantData[user.id] = {
                ...user,
                source: 'users'
              };
            });
          }
        }

        // Log final participant data for debugging
        console.log("ðŸ” Final participant data from users table:", Object.keys(participantData).map(id => ({
          id,
          name: participantData[id].full_name,
          jawatan: participantData[id].jawatan,
          ic: participantData[id].ic,
          source: participantData[id].source
        })));

        // Check for missing users and try to find them by name/IC
        const missingUserIds = Array.from(participantIds).filter(id => !participantData[id]);
        if (missingUserIds.length > 0) {
          console.warn("âš ï¸ Missing users in users table by user_id:", missingUserIds);
          
          // Try to find missing users by name and IC
          const missingParticipants = [];
          if (quizSessions) {
            quizSessions.forEach(session => {
              if (missingUserIds.includes(session.user_id)) {
                missingParticipants.push({
                  user_id: session.user_id,
                  name: session.participant_name,
                  ic: session.participant_ic
                });
              }
            });
          }
          if (checklistResults) {
            checklistResults.forEach(result => {
              if (missingUserIds.includes(result.user_id)) {
                missingParticipants.push({
                  user_id: result.user_id,
                  name: result.participant_name,
                  ic: result.participant_ic
                });
              }
            });
          }
          
          if (missingParticipants.length > 0) {
            console.log("ðŸ” Attempting to find missing users by name and IC...");
            
            // Try to find users by name and IC
            for (const participant of missingParticipants) {
              try {
                const { data: foundUsers } = await supabase
                  .from("users")
                  .select("id, jawatan, full_name, ic, tempat_bertugas, email")
                  .or(`full_name.eq.${participant.name},ic.eq.${participant.ic}`);
                
                if (foundUsers && foundUsers.length > 0) {
                  const foundUser = foundUsers[0]; // Take the first match
                  participantData[participant.user_id] = {
                    ...foundUser,
                    source: 'users_by_name_ic',
                    original_user_id: participant.user_id
                  };
                  console.log(`âœ… Found user by name/IC: ${foundUser.full_name} (${foundUser.ic}) for participant ${participant.name}`);
                }
              } catch (error) {
                console.warn(`âš ï¸ Error finding user by name/IC for ${participant.name}:`, error);
              }
            }
          }
        }
      }

      // Process quiz sessions
      if (quizSessions) {
      console.log("Processing quiz sessions:", quizSessions.length);
      
      // Log all quiz session participants for debugging
      const quizParticipants = quizSessions.map(s => ({
        name: s.participant_name,
        ic: s.participant_ic,
        user_id: s.user_id
      }));
      console.log("All quiz session participants:", quizParticipants);
      
      quizSessions.forEach(session => {
        console.log("Processing quiz session:", {
          quiz_key: session.quiz_key,
          score: session.score,
          participant_name: session.participant_name,
          participant_ic: session.participant_ic,
          user_id: session.user_id
        });
          
          // Try to find existing participant by multiple criteria
          let participant = null;
          let existingKey = null;
          
          // First try exact match
          const exactKey = `${session.participant_name}|${session.participant_ic}`;
          if (participantMap.has(exactKey)) {
            participant = participantMap.get(exactKey);
            existingKey = exactKey;
          } else {
            // Try to find by user_id
            for (const [key, p] of participantMap.entries()) {
              if (p.userId === session.user_id) {
                participant = p;
                existingKey = key;
                break;
              }
            }
            
            // If still not found, try by name only (case insensitive) - combine participants with same name
            if (!participant) {
              for (const [key, p] of participantMap.entries()) {
                if (p.participantName && session.participant_name && 
                    p.participantName.toLowerCase().trim() === session.participant_name.toLowerCase().trim()) {
                  participant = p;
                  existingKey = key;
                  console.log("Found name match for quiz (combining):", key, "name:", session.participant_name);
                  break;
                }
              }
            }
            
            // If still not found, try partial name matching for similar names
            if (!participant) {
              for (const [key, p] of participantMap.entries()) {
                if (p.participantName && session.participant_name) {
                  const pName = p.participantName.toLowerCase().trim();
                  const sName = session.participant_name.toLowerCase().trim();
                  
                  // Check if names contain each other (for cases like "JOHARI" vs "JOHARI BIN AHMAD")
                  if (pName.includes(sName) || sName.includes(pName)) {
                    participant = p;
                    existingKey = key;
                    console.log("Found partial name match for quiz (combining):", key, "pName:", pName, "sName:", sName);
                    break;
                  }
                }
              }
            }
          }
          
          // If no existing participant found, create new one
          if (!participant) {
            const key = `${session.participant_name}|${session.participant_ic}`;
            const userData = participantData[session.user_id];
            
            // Get jawatan with better fallback logic
            const jawatan = getJawatanWithFallback(userData, session.participant_name, session.user_id, session.participant_ic);
            
            const category = getUserCategory(jawatan);
            
            participant = {
              participantName: session.participant_name,
              participantId: session.participant_ic,
              userId: session.user_id,
              jawatan: jawatan,
              category: category,
              preTestScore: null,
              postTestScore: null,
              oneManCprPass: false,
              twoManCprPass: false,
              adultChokingPass: false,
              infantChokingPass: false,
              infantCprPass: false,
              checklistDetails: {
                'one-man-cpr': { performed: [], notPerformed: [] },
                'two-man-cpr': { performed: [], notPerformed: [] },
                'adult-choking': { performed: [], notPerformed: [] },
                'infant-choking': { performed: [], notPerformed: [] },
                'infant-cpr': { performed: [], notPerformed: [] }
              },
              latestResults: {},
              latestAssessmentDate: null
            };
            participantMap.set(key, participant);
            existingKey = key;
          }
          
          // Set quiz scores (with fallback calculation if score is null)
          let finalScore = session.score;
          
          // If score is null, try to calculate from answers
          if (finalScore === null && session.answers) {
            const answerCount = Object.keys(session.answers).filter(key => 
              key !== '_selected_set' && session.answers[key] !== null
            ).length;
            // Estimate score as 70% of answered questions (rough approximation)
            finalScore = Math.round(answerCount * 0.7);
            console.log("Calculated fallback score:", finalScore, "from", answerCount, "answers");
          }
          
          if (session.quiz_key === 'pretest') {
            participant.preTestScore = finalScore;
            console.log("Set pretest score:", finalScore, "for participant:", existingKey);
          } else if (session.quiz_key === 'posttest') {
            participant.postTestScore = finalScore;
            console.log("Set posttest score:", finalScore, "for participant:", existingKey);
          }
          
          // Track latest assessment date (use created_at for actual test date)
          const sessionDate = new Date(session.created_at);
          if (!participant.latestAssessmentDate || sessionDate > new Date(participant.latestAssessmentDate)) {
            participant.latestAssessmentDate = session.created_at;
          }
        });
      }

      // Process checklist results
      if (checklistResults) {
        console.log("Processing checklist results:", checklistResults.length);
        
        // Log all checklist participants for debugging
        const checklistParticipants = checklistResults.map(cr => ({
          name: cr.participant_name,
          ic: cr.participant_ic,
          user_id: cr.user_id
        }));
        console.log("All checklist participants:", checklistParticipants);
        
        checklistResults.forEach(result => {
          console.log("Processing checklist result:", {
            participant_name: result.participant_name,
            participant_ic: result.participant_ic,
            user_id: result.user_id,
            checklist_type: result.checklist_type,
            status: result.status
          });
          
          // Try to find existing participant by multiple criteria
          let participant = null;
          let existingKey = null;
          
          // First try exact match
          const exactKey = `${result.participant_name}|${result.participant_ic}`;
          if (participantMap.has(exactKey)) {
            participant = participantMap.get(exactKey);
            existingKey = exactKey;
            console.log("Found exact match for checklist:", exactKey);
          } else {
            // Try to find by user_id
            for (const [key, p] of participantMap.entries()) {
              if (p.userId === result.user_id) {
                participant = p;
                existingKey = key;
                console.log("Found user_id match for checklist:", key, "user_id:", result.user_id);
                break;
              }
            }
            
            // If still not found, try by name only (case insensitive) - combine participants with same name
            if (!participant) {
              for (const [key, p] of participantMap.entries()) {
                if (p.participantName && result.participant_name && 
                    p.participantName.toLowerCase().trim() === result.participant_name.toLowerCase().trim()) {
                  participant = p;
                  existingKey = key;
                  console.log("Found name match for checklist (combining):", key, "name:", result.participant_name);
                  break;
                }
              }
            }
            
            // If still not found, try partial name matching for similar names
            if (!participant) {
              for (const [key, p] of participantMap.entries()) {
                if (p.participantName && result.participant_name) {
                  const pName = p.participantName.toLowerCase().trim();
                  const rName = result.participant_name.toLowerCase().trim();
                  
                  // Check if names contain each other (for cases like "JOHARI" vs "JOHARI BIN AHMAD")
                  if (pName.includes(rName) || rName.includes(pName)) {
                    participant = p;
                    existingKey = key;
                    console.log("Found partial name match for checklist (combining):", key, "pName:", pName, "rName:", rName);
                    break;
                  }
                }
              }
            }
          }
          
          // If no existing participant found, create new one
          if (!participant) {
            console.log("Creating new participant for checklist result:", {
              participant_name: result.participant_name,
              participant_ic: result.participant_ic,
              user_id: result.user_id,
              checklist_type: result.checklist_type
            });
            const key = `${result.participant_name}|${result.participant_ic}`;
            const userData = participantData[result.user_id];
            
            // Get jawatan with better fallback logic
            const jawatan = getJawatanWithFallback(userData, result.participant_name, result.user_id, result.participant_ic);
            
            const category = getUserCategory(jawatan);
            
            participant = {
              participantName: result.participant_name,
              participantId: result.participant_ic,
              userId: result.user_id,
              jawatan: jawatan,
              category: category,
              preTestScore: null,
              postTestScore: null,
                oneManCprPass: false,
                twoManCprPass: false,
                adultChokingPass: false,
                infantChokingPass: false,
                infantCprPass: false,
                checklistDetails: {
                  'one-man-cpr': { performed: [], notPerformed: [] },
                  'two-man-cpr': { performed: [], notPerformed: [] },
                  'adult-choking': { performed: [], notPerformed: [] },
                  'infant-choking': { performed: [], notPerformed: [] },
                  'infant-cpr': { performed: [], notPerformed: [] }
                },
                latestResults: {},
                latestAssessmentDate: null
            };
            const newKey = `${result.participant_name}|${result.participant_ic}`;
            participantMap.set(newKey, participant);
            existingKey = newKey;
            }
            
          // Set checklist pass status
            const checklistTypeMap = {
              'one-man-cpr': 'oneManCprPass',
              'two-man-cpr': 'twoManCprPass', 
              'adult-choking': 'adultChokingPass',
              'infant-choking': 'infantChokingPass',
              'infant-cpr': 'infantCprPass'
            };
            
            const passKey = checklistTypeMap[result.checklist_type];
          if (passKey) {
            participant[passKey] = result.status === 'PASS';
          }
          
          // Set checklist details
          if (result.checklist_details) {
            participant.checklistDetails[result.checklist_type] = result.checklist_details;
          }
          
          // Store latest result data
          participant.latestResults[result.checklist_type] = {
              status: result.status,
              score: result.score,
              totalItems: result.total_items,
              comments: result.comments || '',
              examinerId: result.user_id,
            examinerName: result.participant_name,
            examinerIc: result.participant_ic,
              assessmentDate: result.created_at
            };
            
          // Track latest assessment date (use created_at for actual test date)
          const resultDate = new Date(result.created_at);
          if (!participant.latestAssessmentDate || resultDate > new Date(participant.latestAssessmentDate)) {
            participant.latestAssessmentDate = result.created_at;
          }
        });
      }

      // Convert to results array - only show participants who have BOTH test and checklist results
      const allParticipants = Array.from(participantMap.values());
      console.log('ðŸ” DEBUG: Total participants in map:', allParticipants.length);
      
      const allResults = allParticipants
        .filter(participant => {
          // Only show participants who have at least one test score OR one checklist result
          const hasTestScore = participant.preTestScore !== null || participant.postTestScore !== null;
          const hasChecklistResult = participant.oneManCprPass || participant.twoManCprPass || 
                                   participant.adultChokingPass || participant.infantChokingPass || 
                                   participant.infantCprPass;
          
          console.log('ðŸ” DEBUG: Participant:', participant.participantName);
          console.log('ðŸ” DEBUG: - hasTestScore:', hasTestScore, '(preTest:', participant.preTestScore, 'postTest:', participant.postTestScore, ')');
          console.log('ðŸ” DEBUG: - hasChecklistResult:', hasChecklistResult);
          console.log('ðŸ” DEBUG: - latestAssessmentDate:', participant.latestAssessmentDate);
          
          const shouldInclude = hasTestScore || hasChecklistResult;
          console.log('ðŸ” DEBUG: - shouldInclude:', shouldInclude);
          
          return shouldInclude;
        })
        .map(participant => {
        const preTestScore = participant.preTestScore;
        const postTestScore = participant.postTestScore;
        
        console.log("Final participant data:", {
          participantName: participant.participantName,
          preTestScore,
          postTestScore,
          oneManCprPass: participant.oneManCprPass,
          twoManCprPass: participant.twoManCprPass
        });
        
        const result = {
            id: `${participant.participantName}-${participant.participantId}`, // Use name+IC as unique ID
          participantName: participant.participantName,
          participantId: participant.participantId,
          jawatan: participant.jawatan || '',
          category: participant.category || 'non-clinical',
          date: participant.latestAssessmentDate ? new Date(participant.latestAssessmentDate).toLocaleDateString() : new Date().toLocaleDateString(),
          preTestScore: preTestScore,
          postTestScore: postTestScore,
          oneManCprPass: participant.oneManCprPass,
          twoManCprPass: participant.twoManCprPass,
          adultChokingPass: participant.adultChokingPass,
          infantChokingPass: participant.infantChokingPass,
          infantCprPass: participant.infantCprPass,
          remedialAllowed: postTestScore !== null ? isPostTestPassing(postTestScore, participant.category || 'non-clinical') : false,
          checklistDetails: participant.checklistDetails,
          latestResults: participant.latestResults,
          latestAssessmentDate: participant.latestAssessmentDate
        };
        
        // Calculate certification status using the proper logic
        result.certified = calculateCertified(result);
        
        return result;
      });

      console.log("Final allResults:", allResults);
      console.log("ðŸ” DEBUG: Total results loaded:", allResults.length);
      if (allResults.length > 0) {
        console.log("ðŸ” DEBUG: Sample result structure:", {
          participantName: allResults[0].participantName,
          latestAssessmentDate: allResults[0].latestAssessmentDate,
          date: allResults[0].date,
          preTestScore: allResults[0].preTestScore,
          postTestScore: allResults[0].postTestScore
        });
      }
      
      // Debug: Log participants with N/A checklist results
      const participantsWithNA = allResults.filter(result => 
        !result.oneManCprPass && !result.twoManCprPass && 
        !result.adultChokingPass && !result.infantChokingPass && 
        !result.infantCprPass && 
        (result.preTestScore !== null || result.postTestScore !== null)
      );
      
      if (participantsWithNA.length > 0) {
        console.log("Participants with test scores but N/A checklist results:", participantsWithNA.map(p => ({
          name: p.participantName,
          id: p.participantId,
          preTest: p.preTestScore,
          postTest: p.postTestScore
        })));
        
        // Check if these participants have checklist results in the raw data
        console.log("Checking if these participants have checklist results...");
        participantsWithNA.forEach(p => {
          const matchingChecklistResults = checklistResults?.filter(cr => 
            cr.participant_name && p.participantName &&
            cr.participant_name.toLowerCase().trim() === p.participantName.toLowerCase().trim()
          );
          if (matchingChecklistResults && matchingChecklistResults.length > 0) {
            console.log(`Found ${matchingChecklistResults.length} checklist results for ${p.participantName}:`, 
              matchingChecklistResults.map(cr => ({
                name: cr.participant_name,
                ic: cr.participant_ic,
                type: cr.checklist_type,
                status: cr.status
              }))
            );
          } else {
            console.log(`No checklist results found for ${p.participantName}`);
          }
        });
      }
      
      setResults(allResults);
    } catch (e) {
      console.error('Error loading results:', e);
      console.error('Error details:', {
        message: e?.message,
        stack: e?.stack,
        name: e?.name
      });
      setError(String(e?.message || e));
      setResults([]);
    } finally {
      console.log("=== loadResults function completed ===");
      setLoading(false);
    }
  }, []);

  // Refresh results
  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    await loadResults();
    setRefreshing(false);
  }, [loadResults]);

  // Load question statistics for both pretest and posttest
  const loadQuestionStatistics = useCallback(async () => {
    try {
      console.log('ðŸ” DEBUG: loadQuestionStatistics called');
      
      // Load pretest questions
      const { data: pretestQuestions } = await supabase
        .from("questions")
        .select("*")
        .eq("soalan_set", "Pre_Test")
        .limit(30);
        
      console.log(`ðŸ” DEBUG: Found ${pretestQuestions?.length || 0} pretest questions`);
      if (pretestQuestions && pretestQuestions.length > 0) {
        console.log(`ðŸ” DEBUG: First 3 pretest question IDs:`, pretestQuestions.slice(0, 3).map(q => q.id));
      }
      
      // Load posttest questions - get all sets first, then filter based on actual usage
      const { data: allPosttestQuestions } = await supabase
        .from("questions")
        .select("*")
        .in("soalan_set", ["SET_A", "SET_B", "SET_C"])
        .limit(90); // Load more to cover all sets

      // Get all quiz sessions to determine which sets were actually used
      const { data: allQuizSessions } = await supabase
        .from("quiz_sessions")
        .select("answers")
        .eq("quiz_key", "posttest")
        .eq("status", "submitted");

      // Extract which sets were actually answered
      const usedSets = new Set();
      if (allQuizSessions) {
        allQuizSessions.forEach(session => {
          if (session.answers?._selected_set) {
            usedSets.add(session.answers._selected_set);
          }
        });
      }

      // Filter questions to only include sets that were actually answered
      const posttestQuestions = allPosttestQuestions?.filter(q => 
        usedSets.has(q.soalan_set)
      ) || [];

      setAllQuestions({
        pretest: pretestQuestions || [],
        posttest: posttestQuestions || []
      });

      // Calculate statistics for pretest
      if (pretestQuestions && pretestQuestions.length > 0) {
        console.log('ðŸ” DEBUG: About to calculate pretest statistics');
        console.log('ðŸ” CRITICAL: Calling calculateQuestionStatistics for pretest');
        const pretestStats = await calculateQuestionStatistics('pretest', pretestQuestions);
        console.log('ðŸ” DEBUG: Pretest statistics calculated:', pretestStats.length);
        setPretestStats(pretestStats);
      } else {
        console.log('ðŸ” DEBUG: No pretest questions found or questions array is empty');
      }

      // Calculate statistics for posttest
      if (posttestQuestions && posttestQuestions.length > 0) {
        console.log('ðŸ” DEBUG: About to calculate posttest statistics');
        const posttestStats = await calculateQuestionStatistics('posttest', posttestQuestions);
        console.log('ðŸ” DEBUG: Posttest statistics calculated:', posttestStats.length);
        setPosttestStats(posttestStats);
      }
    } catch (error) {
      console.error('Error loading question statistics:', error);
    }
  }, []);

  // Load results on component mount
  useEffect(() => {
    console.log("=== BLSResultsScreen useEffect called ===");
    console.log("ðŸ” DEBUG: About to call loadResults and loadQuestionStatistics");
    console.log("ðŸ” CRITICAL: Starting useEffect execution");
    try {
      loadResults();
      console.log("ðŸ” CRITICAL: About to call loadQuestionStatistics");
      loadQuestionStatistics();
      console.log("ðŸ” DEBUG: Called loadResults and loadQuestionStatistics");
    } catch (error) {
      console.error("Error in useEffect:", error);
    }
  }, []);

  // Calculate statistics for questions
  const calculateQuestionStatistics = async (quizType, questions) => {
    try {
      console.log(`ðŸ” DEBUG: calculateQuestionStatistics called for ${quizType} with ${questions.length} questions`);
      console.log(`ðŸ” SIMPLE TEST: Function is running!`);
      console.log(`ðŸ” CRITICAL: About to start comprehensive analysis for ${quizType}`);
      
      // Get all quiz sessions for this quiz type
      const { data: quizSessions } = await supabase
        .from("quiz_sessions")
        .select("answers, score, total_questions")
        .eq("quiz_key", quizType)
        .eq("status", "submitted");




      if (!quizSessions || quizSessions.length === 0) {
        return questions.map(q => ({
          ...q,
          correctCount: 0,
          incorrectCount: 0,
          totalAttempts: 0,
          accuracy: 0,
          mostCommonWrongAnswer: null
        }));
      }

      const questionStats = questions.map(question => {
        let correctCount = 0;
        let incorrectCount = 0;
        let totalAttempts = 0;
        const wrongAnswers = {};
        const answerDistribution = { A: 0, B: 0, C: 0, D: 0 };
        
        // Debug: Show total sessions for first few questions
        if (question.id <= 3) {
          console.log(`ðŸ” DEBUG Question ${question.id} - Total sessions:`, quizSessions.length);
        }

        quizSessions.forEach((session, sessionIndex) => {
          if (session.answers) {
            // Enhanced answer key matching with comprehensive fallback
            let answerKeys = [];
            if (quizType === 'pretest') {
              // For pretest, try all possible answer key formats
              const originalId = question.id; // This is the original database ID
              answerKeys = [
                `malay-${originalId}`,     // malay-1, malay-2, etc. (from PreTestQuestionsScreen)
                `english-${originalId}`,   // english-1, english-2, etc. (from PreTestQuestionsScreen)
                `question_${originalId}`,  // question_1, question_2, etc. (alternative format)
                originalId.toString(),     // 1, 2, 3, etc. (direct ID)
                `q${originalId}`,          // q1, q2, etc. (alternative format)
                `pre-test-${originalId}`,  // pre-test-1, pre-test-2, etc. (alternative format)
                `pretest-${originalId}`    // pretest-1, pretest-2, etc. (alternative format)
              ];
            } else if (quizType === 'posttest') {
              // For posttest, try all possible answer key formats
              answerKeys = [
                `post-test-${question.id}`, // post-test-1, post-test-2, etc. (from PostTestQuestionsScreen)
                `posttest-${question.id}`,  // posttest-1, posttest-2, etc. (alternative format)
                `question_${question.id}`,  // question_1, question_2, etc. (alternative format)
                question.id.toString(),     // 1, 2, 3, etc. (fallback)
                `q${question.id}`,          // q1, q2, etc. (alternative format)
                `malay-${question.id}`,     // malay-1, malay-2, etc. (fallback)
                `english-${question.id}`    // english-1, english-2, etc. (fallback)
              ];
            }
            
            // Debug: Show what we're looking for vs what's available for first few questions
            if (question.id <= 3 && sessionIndex < 2) {
              console.log(`ðŸ” DEBUG Session ${sessionIndex} for Q${question.id}:`, {
                answerKeys,
                availableKeys: Object.keys(session.answers),
                sessionAnswers: session.answers
              });
            }
            
            // Debug: Show answer keys for question 2 specifically
            if (question.id === 2 && sessionIndex < 3) {
              console.log(`ðŸ” DEBUG Q2 Answer Keys:`, answerKeys);
            }
            
            // Enhanced debugging for question 2 - show all available keys for first 10 sessions
            if (question.id === 2 && sessionIndex < 10) {
              console.log(`ðŸ” DEBUG Q2 Session ${sessionIndex} - All available keys:`, {
                sessionId: session.id,
                allKeys: Object.keys(session.answers || {}),
                answers: session.answers
              });
            }

            let userAnswer = null;
            
            // Find the question's position in the questions array (1-based)
            const questionIndex = questions.findIndex(q => q.id === question.id) + 1;
            
            // Find answer using all possible key formats
            const possibleKeys = [
              `malay-${questionIndex}`,
              `english-${questionIndex}`,
              `post-test-${questionIndex}`,
              `malay-${question.id}`,
              `english-${question.id}`,
              `post-test-${question.id}`,
              `question_${question.id}`,
              question.id.toString(),
              `q${question.id}`
            ];
            
            for (const key of possibleKeys) {
              if (session.answers[key] && ['A', 'B', 'C', 'D'].includes(session.answers[key].toUpperCase())) {
                userAnswer = session.answers[key];
                break;
              }
            }
            
            

            if (userAnswer) {
              totalAttempts++;
              const isCorrect = userAnswer === question.correct_option;
              
              
              // Track answer distribution for all answers (A, B, C, D)
              if (['A', 'B', 'C', 'D'].includes(userAnswer)) {
                answerDistribution[userAnswer] = (answerDistribution[userAnswer] || 0) + 1;
              }
              
              if (isCorrect) {
                correctCount++;
              } else {
                incorrectCount++;
                wrongAnswers[userAnswer] = (wrongAnswers[userAnswer] || 0) + 1;
              }
            } else {
              // Debug: Log sessions where no answer was found
              if (question.id <= 3 && sessionIndex < 5) {
                console.log(`ðŸ” DEBUG: No answer found for Q${question.id} Session ${sessionIndex}:`, {
                  availableKeys: Object.keys(session.answers),
                  questionId: question.id,
                  sessionAnswers: session.answers
                });
              }
            }
          }
        });

        // Find most common wrong answer
        const mostCommonWrongAnswer = Object.keys(wrongAnswers).reduce((a, b) => 
          wrongAnswers[a] > wrongAnswers[b] ? a : b, null
        );

        // Debug summary for first few questions
        if (question.id <= 3) {
          console.log(`ðŸ” DEBUG Question ${question.id} Summary:`, {
            correctCount,
            incorrectCount,
            totalAttempts,
            answerDistribution,
            correctAnswer: question.correct_option,
            accuracy: totalAttempts > 0 ? Math.round((correctCount / totalAttempts) * 100) : 0,
            totalSessions: quizSessions.length,
            sessionsWithAnswers: quizSessions.filter(s => s.answers).length,
            missingAnswers: quizSessions.length - totalAttempts
          });
        }
        
        // Special debug for question 2
        if (question.id === 2) {
          console.log(`ðŸ” DEBUG Question 2 DETAILED:`, {
            questionId: question.id,
            correctAnswer: question.correct_option,
            totalSessions: quizSessions.length,
            totalAttempts,
            correctCount,
            incorrectCount,
            answerDistribution,
            wrongAnswers
          });
        }
        
        // Debug: Show detailed breakdown for question 2
        if (question.id === 2) {
          console.log(`ðŸ” DEBUG Question 2 FINAL:`, {
            totalSessions: quizSessions.length,
            sessionsWithAnswers: quizSessions.filter(s => s.answers).length,
            answerDistribution,
            correctAnswer: question.correct_option,
            correctCount,
            incorrectCount,
            totalAttempts,
            accuracy: totalAttempts > 0 ? Math.round((correctCount / totalAttempts) * 100) : 0
          });
        }

        return {
          ...question,
          correctCount,
          incorrectCount,
          totalAttempts,
          accuracy: totalAttempts > 0 ? Math.round((correctCount / totalAttempts) * 100) : 0,
          mostCommonWrongAnswer,
          answerDistribution
        };
      });

      // Sort by incorrect count (descending) to show most problematic questions first
      const sortedStats = questionStats.sort((a, b) => b.incorrectCount - a.incorrectCount);
      
      // Debug: Show comprehensive summary for question 2
      const q2Stats = sortedStats.find(q => q.id === 2);
      if (q2Stats) {
        console.log(`ðŸ” DEBUG Q2 FINAL SUMMARY:`, {
          questionId: q2Stats.id,
          totalSessions: quizSessions.length,
          totalAttempts: q2Stats.totalAttempts,
          correctCount: q2Stats.correctCount,
          incorrectCount: q2Stats.incorrectCount,
          answerDistribution: q2Stats.answerDistribution,
          missingAnswers: quizSessions.length - q2Stats.totalAttempts,
          correctAnswer: q2Stats.correct_option,
          accuracy: q2Stats.accuracy
        });
        
      }
      
      return sortedStats;
    } catch (error) {
      console.error(`Error calculating ${quizType} statistics:`, error);
      return [];
    }
  };

  // Filter results based on search query and date
  const getFilteredResults = useCallback(() => {
    let filtered = [...results];

    console.log('ðŸ” DEBUG: getFilteredResults called');
    console.log('ðŸ” DEBUG: - Total results:', results.length);
    console.log('ðŸ” DEBUG: - Date filter type:', dateFilterType);
    console.log('ðŸ” DEBUG: - Search query:', searchQuery);

    // Filter by search query
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(result => 
        result.participantName.toLowerCase().includes(query) ||
        result.participantId.toLowerCase().includes(query)
      );
      console.log('ðŸ” DEBUG: - After search filter:', filtered.length);
    }

    // Filter by date based on filter type
    if (dateFilterType !== 'all') {
      const today = new Date();
      const todayString = today.toDateString();
      
      console.log('ðŸ” DEBUG: - Applying date filter:', dateFilterType);
      console.log('ðŸ” DEBUG: - Before date filter:', filtered.length);
      
      filtered = filtered.filter(result => {
        // Use the original latestAssessmentDate if available, otherwise use the date field
        const resultDate = result.latestAssessmentDate ? new Date(result.latestAssessmentDate) : new Date(result.date);
        
        console.log('ðŸ” DEBUG: - Result:', result.participantName);
        console.log('ðŸ” DEBUG: - - latestAssessmentDate:', result.latestAssessmentDate);
        console.log('ðŸ” DEBUG: - - date field:', result.date);
        console.log('ðŸ” DEBUG: - - parsed date:', resultDate.toDateString());
        console.log('ðŸ” DEBUG: - - isValid:', !isNaN(resultDate.getTime()));
        
        switch (dateFilterType) {
          case 'today':
            const isToday = resultDate.toDateString() === todayString;
            console.log('ðŸ” DEBUG: - - Is today?', isToday);
            return isToday;
          
          case '7days':
            const sevenDaysAgo = new Date(today);
            sevenDaysAgo.setDate(today.getDate() - 7);
            const isWithin7Days = resultDate >= sevenDaysAgo && resultDate <= today;
            console.log('ðŸ” DEBUG: - - Is within 7 days?', isWithin7Days);
            return isWithin7Days;
          
          case '30days':
            const thirtyDaysAgo = new Date(today);
            thirtyDaysAgo.setDate(today.getDate() - 30);
            const isWithin30Days = resultDate >= thirtyDaysAgo && resultDate <= today;
            console.log('ðŸ” DEBUG: - - Is within 30 days?', isWithin30Days);
            return isWithin30Days;
          
          case 'custom':
            if (dateFilter) {
              const filterDate = new Date(dateFilter).toDateString();
              const isCustomDate = resultDate.toDateString() === filterDate;
              console.log('ðŸ” DEBUG: - - Is custom date?', isCustomDate);
              return isCustomDate;
            }
            return true;
          
          default:
            return true;
        }
      });
      
      console.log('ðŸ” DEBUG: - After date filter:', filtered.length);
    } else {
      console.log('ðŸ” DEBUG: - No date filter applied (all time)');
    }

    // Sort by name (A-Z)
    filtered.sort((a, b) => {
      const nameA = a.participantName.toLowerCase();
      const nameB = b.participantName.toLowerCase();
      return nameA.localeCompare(nameB);
    });

    console.log('ðŸ” DEBUG: - Final filtered results:', filtered.length);
    return filtered;
  }, [results, searchQuery, dateFilter, dateFilterType]);

  // Get paginated results
  const getPaginatedResults = useCallback(() => {
    const filtered = getFilteredResults();
    const startIndex = (currentPage - 1) * resultsPerPage;
    const endIndex = startIndex + resultsPerPage;
    return filtered.slice(startIndex, endIndex);
  }, [getFilteredResults, currentPage, resultsPerPage]);

  // Get total pages
  const getTotalPages = useCallback(() => {
    const filtered = getFilteredResults();
    return Math.ceil(filtered.length / resultsPerPage);
  }, [getFilteredResults, resultsPerPage]);

  // Handle results per page change
  const handleResultsPerPageChange = (newResultsPerPage) => {
    setResultsPerPage(newResultsPerPage);
    setCurrentPage(1); // Reset to first page
  };

  // Handle page change
  const handlePageChange = (newPage) => {
    setCurrentPage(newPage);
  };

  // Reset pagination when filters change
  useEffect(() => {
    setCurrentPage(1);
  }, [searchQuery, dateFilter, dateFilterType]);

  // Handle metric card clicks to show participants
  const handleMetricCardClick = (category, filterType) => {
    const allResults = getFilteredResults();
    let filtered = [];

    switch (filterType) {
      case 'clinical':
        filtered = allResults.filter(r => r.category === 'clinical');
        setSelectedCategory('Clinical Staff');
        break;
      case 'non-clinical':
        filtered = allResults.filter(r => r.category === 'non-clinical');
        setSelectedCategory('Non-Clinical Staff');
        break;
      case 'pre-test-pass':
        filtered = allResults.filter(r => 
          r.preTestScore !== null && isPostTestPassing(r.preTestScore, r.category)
        );
        setSelectedCategory('Pre-Test Pass');
        break;
      case 'post-test-pass':
        filtered = allResults.filter(r => 
          r.postTestScore !== null && isPostTestPassing(r.postTestScore, r.category)
        );
        setSelectedCategory('Post-Test Pass');
        break;
      case 'remedial-allowed':
        filtered = allResults.filter(r => 
          calculateRemedialAllowed(r.postTestScore, r.category)
        );
        setSelectedCategory('Remedial Allowed');
        break;
      case 'certified-eligible':
        filtered = allResults.filter(r => 
          calculateCertified(r) === true
        );
        setSelectedCategory('Certified Eligible');
        break;
      default:
        filtered = allResults;
        setSelectedCategory('All Participants');
    }

    setFilteredParticipants(filtered);
    setParticipantModalVisible(true);
  };

  // Handle test statistic clicks to show specific pass/fail participants
  const handleTestStatClick = (testType) => {
    const allResults = getFilteredResults();
    let filtered = [];
    let category = '';

    switch (testType) {
      case 'pre-test-pass':
        filtered = allResults.filter(r => 
          r.preTestScore !== null && isPostTestPassing(r.preTestScore, r.category)
        );
        category = 'Pre-Test Pass';
        break;
      case 'pre-test-fail':
        filtered = allResults.filter(r => 
          r.preTestScore !== null && !isPostTestPassing(r.preTestScore, r.category)
        );
        category = 'Pre-Test Fail';
        break;
      case 'post-test-pass':
        filtered = allResults.filter(r => 
          r.postTestScore !== null && isPostTestPassing(r.postTestScore, r.category)
        );
        category = 'Post-Test Pass';
        break;
      case 'post-test-fail':
        filtered = allResults.filter(r => 
          r.postTestScore !== null && !isPostTestPassing(r.postTestScore, r.category)
        );
        category = 'Post-Test Fail';
        break;
      default:
        filtered = allResults;
        category = 'All Participants';
    }

    setSelectedCategory(category);
    setFilteredParticipants(filtered);
    setParticipantModalVisible(true);
  };

  // Export results to CSV
  const exportToCSV = async () => {
    try {
      const filteredResults = getFilteredResults();
      
      if (filteredResults.length === 0) {
        Alert.alert("No Data", "No results to export.");
        return;
      }

      // Create CSV headers
      const headers = [
        'No',
        'Date',
        'Name',
        'IC',
        'Jawatan',
        'Category',
        'One Man CPR',
        'Two Man CPR',
        'Adult Choking',
        'Infant Choking',
        'Infant CPR',
        'Pre Test Score',
        'Post Test Score',
        'Remedial Allowed',
        'Certified'
      ];

      // Create CSV rows
      const csvRows = filteredResults.map((result, index) => {
        const row = [
          index + 1,
          result.date,
          `"${result.participantName}"`,
          result.participantId,
          `"${result.jawatan || 'N/A'}"`,
          result.category,
          result.oneManCprPass ? 'PASS' : 'FAIL',
          result.twoManCprPass ? 'PASS' : 'FAIL',
          result.adultChokingPass ? 'PASS' : 'FAIL',
          result.infantChokingPass ? 'PASS' : 'FAIL',
          result.infantCprPass ? 'PASS' : 'FAIL',
          result.preTestScore !== null ? result.preTestScore : 'N/A',
          result.postTestScore !== null ? result.postTestScore : 'N/A',
          calculateRemedialAllowed(result.postTestScore, result.category) ? 'ALLOW' : 'NOT ALLOW',
          calculateCertified(result) ? 'YES' : 'NO'
        ];
        return row.join(',');
      });

      // Combine headers and rows
      const csvContent = [headers.join(','), ...csvRows].join('\n');

      // Generate filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const filename = `BLS_Results_${timestamp}.csv`;

      if (Platform.OS === 'web') {
        // Web platform - use blob download
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        Alert.alert("Export Complete", `File downloaded as: ${filename}`);
      } else {
        // Mobile platform - use expo-file-system
        const fileUri = FileSystem.documentDirectory + filename;
        await FileSystem.writeAsStringAsync(fileUri, csvContent, {
          encoding: FileSystem.EncodingType.UTF8,
        });

        // Check if sharing is available
        const isAvailable = await Sharing.isAvailableAsync();
        if (isAvailable) {
          await Sharing.shareAsync(fileUri, {
            mimeType: 'text/csv',
            dialogTitle: 'Export BLS Results',
          });
        } else {
          Alert.alert("Export Complete", `File saved as: ${filename}`);
        }
      }

    } catch (error) {
      console.error('Error exporting CSV:', error);
      Alert.alert("Export Error", "Failed to export results. Please try again.");
    }
  };

  // Get statistics for current tab
  const getCurrentStats = () => {
    console.log('ðŸ” DEBUG getCurrentStats:', { activeTab, pretestStatsLength: pretestStats.length, posttestStatsLength: posttestStats.length });
    if (activeTab === 'pretest') {
      return pretestStats;
    } else if (activeTab === 'posttest') {
      return posttestStats;
    }
    return [];
  };

  // Calculate new dashboard statistics
  const getNewDashboardStats = useCallback(() => {
    const allResults = getFilteredResults();
    const totalParticipants = allResults.length;

    if (totalParticipants === 0) {
      return {
        highestScores: { clinical: 0, nonClinical: 0 },
        passFailStats: { preTest: { pass: 0, fail: 0, total: 0 }, postTest: { pass: 0, fail: 0, total: 0 } },
        questionAnalysis: []
      };
    }

    // 1. Highest scores for clinical and non-clinical
    const clinicalResults = allResults.filter(r => r.category === 'clinical');
    const nonClinicalResults = allResults.filter(r => r.category === 'non-clinical');
    
    const highestClinicalPre = clinicalResults.length > 0 ? Math.max(...clinicalResults.map(r => r.preTestScore || 0)) : 0;
    const highestClinicalPost = clinicalResults.length > 0 ? Math.max(...clinicalResults.map(r => r.postTestScore || 0)) : 0;
    const highestNonClinicalPre = nonClinicalResults.length > 0 ? Math.max(...nonClinicalResults.map(r => r.preTestScore || 0)) : 0;
    const highestNonClinicalPost = nonClinicalResults.length > 0 ? Math.max(...nonClinicalResults.map(r => r.postTestScore || 0)) : 0;

    // 2. Pass/Fail counts - Fix: Use total participants who took the test, not just pass+fail
    const preTestParticipants = allResults.filter(r => r.preTestScore !== null);
    const postTestParticipants = allResults.filter(r => r.postTestScore !== null);
    
    const preTestPass = preTestParticipants.filter(r => 
      isPostTestPassing(r.preTestScore, r.category)
    ).length;
    const preTestFail = preTestParticipants.filter(r => 
      !isPostTestPassing(r.preTestScore, r.category)
    ).length;
    const postTestPass = postTestParticipants.filter(r => 
      isPostTestPassing(r.postTestScore, r.category)
    ).length;
    const postTestFail = postTestParticipants.filter(r => 
      !isPostTestPassing(r.postTestScore, r.category)
    ).length;

    return {
      highestScores: {
        clinical: { preTest: highestClinicalPre, postTest: highestClinicalPost },
        nonClinical: { preTest: highestNonClinicalPre, postTest: highestNonClinicalPost }
      },
      passFailStats: {
        preTest: { pass: preTestPass, fail: preTestFail, total: preTestParticipants.length },
        postTest: { pass: postTestPass, fail: postTestFail, total: postTestParticipants.length }
      },
      totalParticipants
    };
  }, [getFilteredResults]);

  // Show highest scorers modal
  const showHighestScorers = (category) => {
    try {
      const allResults = getFilteredResults();
      const testType = activeTab === 'pretest' ? 'preTest' : 'postTest';
      const scoreField = testType === 'preTest' ? 'preTestScore' : 'postTestScore';
      
      console.log('ðŸ” DEBUG: showHighestScorers called', { category, testType, scoreField });
      console.log('ðŸ” DEBUG: allResults length:', allResults.length);
      
      const categoryResults = allResults.filter(r => r.category === category);
      console.log('ðŸ” DEBUG: categoryResults length:', categoryResults.length);
      
      // Filter participants who actually took the test
      const testParticipants = categoryResults.filter(r => r[scoreField] !== null && r[scoreField] !== undefined);
      console.log('ðŸ” DEBUG: testParticipants length:', testParticipants.length);
      
      if (testParticipants.length === 0) {
        Alert.alert(
          `Top ${category === 'clinical' ? 'Clinical' : 'Non-Clinical'} Scorers`,
          `No ${category} participants have taken the ${testType === 'preTest' ? 'pre-test' : 'post-test'} yet.`,
          [{ text: 'OK' }]
        );
        return;
      }
      
      // Get top 3 scorers (ranked by score)
      const topScorers = testParticipants
        .map(r => ({
          name: r.participantName,
          score: r[scoreField],
          date: r.date,
          jawatan: r.jawatan
        }))
        .sort((a, b) => b.score - a.score) // Sort by score descending
        .slice(0, 3); // Show top 3 only
      
      const highestScore = topScorers.length > 0 ? topScorers[0].score : 0;
      console.log('ðŸ” DEBUG: top 3 scorers:', topScorers);
      console.log('ðŸ” DEBUG: highestScore:', highestScore);
      
      console.log('ðŸ” DEBUG: topScorers:', topScorers);
      
      if (topScorers.length === 0) {
        Alert.alert(
          `Top ${category === 'clinical' ? 'Clinical' : 'Non-Clinical'} Scorers`,
          `No participants found with the highest score of ${highestScore}/30`,
          [{ text: 'OK' }]
        );
        return;
      }
      
      // Show modal with top 3 scorers using custom modal
      console.log('ðŸ” DEBUG: About to show custom modal');
      const modalTitle = `Top 3 ${category === 'clinical' ? 'Clinical' : 'Non-Clinical'} Scorers`;
      const modalMessage = `Top Performance Rankings`;
      
      console.log('ðŸ” DEBUG: Modal title:', modalTitle);
      console.log('ðŸ” DEBUG: Modal message:', modalMessage);
      console.log('ðŸ” DEBUG: Top scorers:', topScorers);
      
      setHighestScorersData({
        title: modalTitle,
        message: modalMessage,
        scorers: topScorers
      });
      setShowHighestScorersModal(true);
    } catch (error) {
      console.error('Error in showHighestScorers:', error);
      Alert.alert('Error', 'Failed to load highest scorers data');
    }
  };


  // Calculate question analysis with real data
  const getQuestionAnalysis = useCallback(() => {
    const allResults = getFilteredResults();
    const testType = activeTab === 'pretest' ? 'preTest' : 'postTest';
    
    if (allResults.length === 0) return [];
    
    // Get questions from the current stats
    const currentStats = getCurrentStats();
    
    // Sort by accuracy (lowest first - most problematic)
    const sortedQuestions = currentStats
      .sort((a, b) => a.accuracy - b.accuracy)
      .slice(0, 10); // Top 10 most problematic
    
    return sortedQuestions.map((question, index) => {
      // Use the actual data from the database
      const totalAnswered = question.totalAttempts || 0;
      const correctCount = question.correctCount || 0;
      const incorrectCount = question.incorrectCount || 0;
      
      // Calculate real accuracy percentage based on total participants who took the test
      const totalParticipants = getFilteredResults().length;
      const realAccuracy = totalParticipants > 0 ? (correctCount / totalParticipants) * 100 : 0;
      
      
      
      // Use real answer distribution data
      const answerChoices = {
        A: {
          count: question.answerDistribution?.A || 0,
          text: question.option_a || `Option A`,
          isCorrect: question.correct_option === 'A'
        },
        B: {
          count: question.answerDistribution?.B || 0,
          text: question.option_b || `Option B`,
          isCorrect: question.correct_option === 'B'
        },
        C: {
          count: question.answerDistribution?.C || 0,
          text: question.option_c || `Option C`,
          isCorrect: question.correct_option === 'C'
        },
        D: {
          count: question.answerDistribution?.D || 0,
          text: question.option_d || `Option D`,
          isCorrect: question.correct_option === 'D'
        }
      };
      
      // Find most common wrong answer
      const mostCommonWrong = Object.entries(answerChoices)
        .filter(([key, value]) => key !== question.correct_option)
        .sort((a, b) => b[1].count - a[1].count)[0]?.[0] || 'A';
      
      // Generate improvement suggestions based on real accuracy
      let suggestion = '';
      if (realAccuracy < 30) {
        suggestion = "Critical issue: Consider additional training sessions, hands-on practice, and review of basic concepts. This question needs immediate attention.";
      } else if (realAccuracy < 50) {
        suggestion = "Poor performance: Focus on interactive learning, visual aids, and repeated practice. Consider breaking down the concept into smaller parts.";
      } else if (realAccuracy < 70) {
        suggestion = "Below average: Review teaching methods, provide more examples, and encourage group discussions to clarify misconceptions.";
      } else if (realAccuracy < 90) {
        suggestion = "Good performance: Continue current methods but identify specific areas for improvement. Consider advanced practice scenarios.";
      } else {
        suggestion = "Excellent performance: Maintain current training standards. Use this as a reference for other questions.";
      }
      
      return {
        questionId: question.id,
        questionText: question.question_text,
        correctAnswer: question.correct_option,
        totalAnswered: totalAnswered,
        correctCount: correctCount, // This should now show the real correct count
        incorrectCount: incorrectCount, // This should now show the real incorrect count
        accuracy: realAccuracy, // Use real calculated accuracy based on total participants
        mostCommonWrongAnswer: mostCommonWrong,
        answerChoices: answerChoices,
        suggestion: suggestion
      };
    });
  }, [getCurrentStats, getFilteredResults, activeTab]);

  // Calculate dashboard statistics (keeping old function for compatibility)
  const getDashboardStats = useCallback(() => {
    const allResults = getFilteredResults();
    const totalParticipants = allResults.length;

    if (totalParticipants === 0) {
      return {
        clinical: { count: 0, percentage: 0 },
        nonClinical: { count: 0, percentage: 0 },
        preTestPass: { count: 0, percentage: 0 },
        preTestFail: { count: 0, percentage: 0 },
        postTestPass: { count: 0, percentage: 0 },
        postTestFail: { count: 0, percentage: 0 },
        remedialAllowed: { count: 0, percentage: 0 },
        remedialNotAllowed: { count: 0, percentage: 0 },
        certifiedEligible: { count: 0, percentage: 0 },
        certifiedNotEligible: { count: 0, percentage: 0 }
      };
    }

    // Clinical vs Non-clinical
    const clinicalCount = allResults.filter(r => r.category === 'clinical').length;
    const nonClinicalCount = totalParticipants - clinicalCount;

    // Pre-test Pass/Fail
    const preTestPassCount = allResults.filter(r => 
      r.preTestScore !== null && isPostTestPassing(r.preTestScore, r.category)
    ).length;
    const preTestFailCount = allResults.filter(r => 
      r.preTestScore !== null && !isPostTestPassing(r.preTestScore, r.category)
    ).length;

    // Post-test Pass/Fail
    const postTestPassCount = allResults.filter(r => 
      r.postTestScore !== null && isPostTestPassing(r.postTestScore, r.category)
    ).length;
    const postTestFailCount = allResults.filter(r => 
      r.postTestScore !== null && !isPostTestPassing(r.postTestScore, r.category)
    ).length;

    // Remedial Allowed
    const remedialAllowedCount = allResults.filter(r => 
      calculateRemedialAllowed(r.postTestScore, r.category)
    ).length;
    const remedialNotAllowedCount = totalParticipants - remedialAllowedCount;

    // Certification Eligibility
    const certifiedEligibleCount = allResults.filter(r => 
      calculateCertified(r) === true
    ).length;
    const certifiedNotEligibleCount = totalParticipants - certifiedEligibleCount;

    return {
      clinical: { 
        count: clinicalCount, 
        percentage: Math.round((clinicalCount / totalParticipants) * 100) 
      },
      nonClinical: { 
        count: nonClinicalCount, 
        percentage: Math.round((nonClinicalCount / totalParticipants) * 100) 
      },
      preTestPass: { 
        count: preTestPassCount, 
        percentage: preTestPassCount > 0 ? Math.round((preTestPassCount / (preTestPassCount + preTestFailCount)) * 100) : 0 
      },
      preTestFail: { 
        count: preTestFailCount, 
        percentage: preTestFailCount > 0 ? Math.round((preTestFailCount / (preTestPassCount + preTestFailCount)) * 100) : 0 
      },
      postTestPass: { 
        count: postTestPassCount, 
        percentage: postTestPassCount > 0 ? Math.round((postTestPassCount / (postTestPassCount + postTestFailCount)) * 100) : 0 
      },
      postTestFail: { 
        count: postTestFailCount, 
        percentage: postTestFailCount > 0 ? Math.round((postTestFailCount / (postTestPassCount + postTestFailCount)) * 100) : 0 
      },
      remedialAllowed: { 
        count: remedialAllowedCount, 
        percentage: Math.round((remedialAllowedCount / totalParticipants) * 100) 
      },
      remedialNotAllowed: { 
        count: remedialNotAllowedCount, 
        percentage: Math.round((remedialNotAllowedCount / totalParticipants) * 100) 
      },
      certifiedEligible: { 
        count: certifiedEligibleCount, 
        percentage: Math.round((certifiedEligibleCount / totalParticipants) * 100) 
      },
      certifiedNotEligible: { 
        count: certifiedNotEligibleCount, 
        percentage: Math.round((certifiedNotEligibleCount / totalParticipants) * 100) 
      }
    };
  }, [getFilteredResults]);

  // Simple date picker component
  const renderDatePicker = () => {
    const currentDate = selectedDate;
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const day = currentDate.getDate();
    
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const firstDayOfMonth = new Date(year, month, 1).getDay();
    
    const monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    const renderCalendarDays = () => {
      const days = [];
      
      // Empty cells for days before the first day of the month
      for (let i = 0; i < firstDayOfMonth; i++) {
        days.push(
          <View key={`empty-${i}`} style={styles.calendarDayEmpty} />
        );
      }
      
      // Days of the month
      for (let i = 1; i <= daysInMonth; i++) {
        const isSelected = i === day;
        const isToday = new Date().toDateString() === new Date(year, month, i).toDateString();
        
        days.push(
          <TouchableOpacity
            key={i}
            style={[
              styles.calendarDay,
              isSelected && styles.calendarDaySelected,
              isToday && !isSelected && styles.calendarDayToday
            ]}
            onPress={() => setSelectedDate(new Date(year, month, i))}
          >
            <Text style={[
              styles.calendarDayText,
              isSelected && styles.calendarDayTextSelected,
              isToday && !isSelected && styles.calendarDayTextToday
            ]}>
              {i}
            </Text>
          </TouchableOpacity>
        );
      }
      
      return days;
    };
    
    const navigateMonth = (direction) => {
      const newDate = new Date(selectedDate);
      newDate.setMonth(month + direction);
      setSelectedDate(newDate);
    };
    
    return (
      <View style={styles.calendarContainer}>
        <View style={styles.calendarHeader}>
          <TouchableOpacity onPress={() => navigateMonth(-1)} style={styles.calendarNavButton}>
            <MaterialCommunityIcons name="chevron-left" size={24} color="#00ffc8" />
          </TouchableOpacity>
          <Text style={styles.calendarMonthYear}>
            {monthNames[month]} {year}
          </Text>
          <TouchableOpacity onPress={() => navigateMonth(1)} style={styles.calendarNavButton}>
            <MaterialCommunityIcons name="chevron-right" size={24} color="#00ffc8" />
          </TouchableOpacity>
        </View>
        
        <View style={styles.calendarDayNames}>
          {dayNames.map(dayName => (
            <Text key={dayName} style={styles.calendarDayName}>{dayName}</Text>
          ))}
        </View>
        
        <View style={styles.calendarDays}>
          {renderCalendarDays()}
        </View>
      </View>
    );
  };

  // Calculate remedial status based on post-test score and category
  const calculateRemedialAllowed = (postTestScore, category = 'non-clinical') => {
    if (postTestScore === null) {
      return false; // No post-test taken, not allowed
    }
    return isPostTestPassing(postTestScore, category); // Only allowed if passing (green score)
  };

  // Get score color based on category and score
  const getScoreColor = (score, category, testType) => {
    if (score === null) return '#8a7f6a'; // N/A color
    
    const isClinical = category === 'clinical';
    const threshold = isClinical ? 25 : 20;
    
    return score < threshold ? '#dc3545' : '#28a745'; // Red if below threshold, green if above
  };

  // Get score text color for display
  const getScoreTextColor = (score, category, testType) => {
    if (score === null) return '#8a7f6a'; // N/A color
    
    const isClinical = category === 'clinical';
    const threshold = isClinical ? 25 : 20;
    
    return score < threshold ? '#dc3545' : '#28a745'; // Red if below threshold, green if above
  };

  // Check if post-test score is passing (green) based on category thresholds
  const isPostTestPassing = (score, category) => {
    if (score === null) return false; // No score means not passing
    
    const isClinical = category === 'clinical';
    const threshold = isClinical ? 25 : 20;
    
    return score >= threshold; // Pass if score meets or exceeds threshold
  };

  // Calculate certification status based on all checklists passed AND post-test passing (green score)
  const calculateCertified = (result) => {
    // Check if all required assessments are available using latestResults
    const hasAllChecklists = result.latestResults && 
                            result.latestResults['one-man-cpr'] && result.latestResults['one-man-cpr'].status &&
                            result.latestResults['two-man-cpr'] && result.latestResults['two-man-cpr'].status &&
                            result.latestResults['adult-choking'] && result.latestResults['adult-choking'].status &&
                            result.latestResults['infant-choking'] && result.latestResults['infant-choking'].status &&
                            result.latestResults['infant-cpr'] && result.latestResults['infant-cpr'].status;
    
    const hasPostTest = result.postTestScore !== null;
    
    // Only calculate certification if all assessments are available
    if (!hasAllChecklists || !hasPostTest) {
      return null; // Not enough data to determine certification
    }
    
    const allChecklistsPassed = result.oneManCprPass && 
                               result.twoManCprPass && 
                               result.adultChokingPass && 
                               result.infantChokingPass && 
                               result.infantCprPass;
    
    // Use the new post-test passing logic based on category thresholds
    const postTestPassed = isPostTestPassing(result.postTestScore, result.category);
    
    return allChecklistsPassed && postTestPassed;
  };

  // View detailed results
  const viewDetails = (result) => {
    setSelectedResult(result);
    setShowDetailModal(true);
  };

  // View checklist details
  const viewChecklistDetails = (result, checklistType) => {
    if (result.checklistDetails && result.checklistDetails[checklistType]) {
      // Get the latest result data for this checklist type
      const latestResult = result.latestResults?.[checklistType] || {};
      
      setSelectedChecklist({
        participantName: result.participantName,
        participantId: result.participantId,
        checklistType: checklistType,
        details: result.checklistDetails[checklistType],
        comments: latestResult.comments || '',
        examinerId: currentUser?.id || 'Unknown',
        examinerName: currentUser?.user_metadata?.full_name || currentUser?.email || 'Unknown',
        examinerIc: currentUser?.user_metadata?.ic || 'Unknown',
        score: latestResult.score || 0,
        totalItems: latestResult.totalItems || 0,
        status: latestResult.status || 'UNKNOWN',
        assessmentDate: latestResult.assessmentDate || new Date().toISOString()
      });
      setShowChecklistModal(true);
    }
  };

  // View pretest details
  const viewPretestDetails = async (result) => {
    if (result.preTestScore === null || result.preTestScore === undefined) return;
    
    try {
      setLoading(true);
      
      // Find the quiz session for this participant
      const { data: quizSessions } = await supabase
        .from("quiz_sessions")
        .select("id, answers, score, total_questions")
        .eq("quiz_key", "pretest")
        .eq("status", "submitted")
        .or(`participant_name.ilike.%${result.participantName}%,participant_ic.eq.${result.participantId}`);
      
      if (!quizSessions || quizSessions.length === 0) {
        console.log("No pretest session found for participant");
        return;
      }
      
      const session = quizSessions[0];
      
      // Load pretest questions from database
      const { data: questionData, error } = await supabase
        .from("questions")
        .select("*")
        .eq("soalan_set", "Pre_Test")
        .limit(30);
      
      if (error) {
        console.error("Error fetching pretest questions:", error);
        return;
      }
      
      // Process questions similar to PreTestQuestionsScreen
      const processedQuestions = processQuestionsFromDatabase(questionData || [], false);
      
      // Match questions with answers
      const questionsWithAnswers = processedQuestions.map(question => {
        // Try to find the user's answer by matching question ID with answer keys
        // Answer keys are like "malay-2", "english-2", "pre-test-2" where 2 is the question ID
        let userAnswer = null;
        
        // First try malay answers (most likely to have the answer)
        const malayKey = `malay-${question.id}`;
        if (session.answers[malayKey]) {
          userAnswer = session.answers[malayKey];
        } else {
          // Try english answers as fallback
          const englishKey = `english-${question.id}`;
          if (session.answers[englishKey]) {
            userAnswer = session.answers[englishKey];
          } else {
            // Try pre-test answers as last resort
            const pretestKey = `pre-test-${question.id}`;
            if (session.answers[pretestKey]) {
              userAnswer = session.answers[pretestKey];
            }
          }
        }
        
        const isCorrect = userAnswer === question.correctAnswer;
        
        // Debug logging for the first few questions
        if (processedQuestions.indexOf(question) < 3) {
          console.log(`ðŸ” DEBUG Question ${question.id}:`, {
            malayKey,
            englishKey: `english-${question.id}`,
            pretestKey: `pre-test-${question.id}`,
            userAnswer,
            correctAnswer: question.correctAnswer,
            isCorrect,
            malayAnswer: session.answers[malayKey],
            englishAnswer: session.answers[`english-${question.id}`],
            pretestAnswer: session.answers[`pre-test-${question.id}`]
          });
        }
        
        return {
          ...question,
          userAnswer,
          isCorrect,
          correctAnswer: question.correctAnswer
        };
      });
      
      setSelectedPretest({
        participantName: result.participantName,
        participantId: result.participantId,
        category: result.category,
        score: session.score,
        totalQuestions: session.total_questions,
        sessionId: session.id
      });
      
      setPretestQuestions(questionsWithAnswers);
      setShowPretestModal(true);
      
    } catch (error) {
      console.error("Error loading pretest details:", error);
    } finally {
      setLoading(false);
    }
  };

  // View posttest details
  const viewPosttestDetails = async (result) => {
    console.log("ðŸ” DEBUG: viewPosttestDetails called for participant:", result.participantName);
    if (result.postTestScore === null || result.postTestScore === undefined) {
      console.log("ðŸ” DEBUG: No posttest score, returning early");
      return;
    }
    
    try {
      setLoading(true);
      console.log("ðŸ” DEBUG: Starting posttest details loading...");
      
      // Find the quiz session for this participant
      const { data: quizSessions } = await supabase
        .from("quiz_sessions")
        .select("id, answers, score, total_questions")
        .eq("quiz_key", "posttest")
        .eq("status", "submitted")
        .or(`participant_name.ilike.%${result.participantName}%,participant_ic.eq.${result.participantId}`);
      
      if (!quizSessions || quizSessions.length === 0) {
        console.log("ðŸ” DEBUG: No posttest session found for participant");
        return;
      }
      
      const session = quizSessions[0];
      console.log("ðŸ” DEBUG: Found quiz session:", session.id);
      console.log("ðŸ” DEBUG: Session answers keys:", Object.keys(session.answers || {}));
      
      // Get the specific set that was answered by this participant
      let selectedSet = session.answers?._selected_set;
      console.log("ðŸ” DEBUG: Participant answered set:", selectedSet);
      
      // If no selected set found, try to determine it from the answers or use default
      if (!selectedSet) {
        console.log("No _selected_set found in answers, attempting to determine set...");
        
        // Try to determine set from answer keys or use default
        const answerKeys = Object.keys(session.answers || {}).filter(k => k !== '_selected_set');
        console.log("Available answer keys:", answerKeys);
        
        // For older sessions without _selected_set, default to SET_A
        // This is safe because most generated data uses SET_A
        selectedSet = 'SET_A';
        console.log("Using default set:", selectedSet);
      }
      
      // Load posttest questions from database for the specific set that was answered
      const { data: questionData, error } = await supabase
        .from("questions")
        .select("*")
        .eq("soalan_set", selectedSet)
        .limit(30);
      
      if (error) {
        console.error("Error fetching posttest questions:", error);
        return;
      }
      
      // Process questions similar to PostTestQuestionsScreen
      const processedQuestions = processQuestionsFromDatabase(questionData || [], true);
      
      // Debug: Log the original question data and processed questions
      console.log("ðŸ” DEBUG: Participant answered set:", selectedSet);
      console.log("ðŸ” DEBUG: Total questions loaded:", questionData?.length);
      console.log("ðŸ” DEBUG: Total processed questions:", processedQuestions.length);
      console.log("ðŸ” DEBUG: Session answer keys:", Object.keys(session.answers || {}).filter(k => k !== '_selected_set'));
      console.log("ðŸ” DEBUG: Processed question IDs:", processedQuestions.map(q => q.id));
      console.log("ðŸ” DEBUG: Sample answer keys:", Object.keys(session.answers || {}).filter(k => k !== '_selected_set').slice(0, 5));
      console.log("ðŸ” DEBUG: Sample processed IDs:", processedQuestions.slice(0, 3).map(q => q.id));
      
      // Debug: Show the first few questions from database
      if (questionData && questionData.length > 0) {
        console.log("ðŸ” DEBUG: First question from database:", {
          id: questionData[0].id,
          soalan_set: questionData[0].soalan_set,
          question_text: questionData[0].question_text?.substring(0, 50) + "...",
          correct_option: questionData[0].correct_option
        });
      }
      
      // Debug: Show the first few processed questions
      if (processedQuestions.length > 0) {
        console.log("ðŸ” DEBUG: First processed question:", {
          id: processedQuestions[0].id,
          text: processedQuestions[0].text?.substring(0, 50) + "...",
          correctAnswer: processedQuestions[0].correctAnswer
        });
      }
      
      // Check for ID mismatches
      const answerKeys = Object.keys(session.answers || {}).filter(k => k !== '_selected_set');
      const processedIds = processedQuestions.map(q => q.id);
      const matchedIds = answerKeys.filter(key => processedIds.includes(key));
      const unmatchedAnswerKeys = answerKeys.filter(key => !processedIds.includes(key));
      const unmatchedProcessedIds = processedIds.filter(id => !answerKeys.includes(id));
      
      console.log("ðŸ” DEBUG: Matched IDs:", matchedIds.length, matchedIds);
      console.log("ðŸ” DEBUG: Unmatched answer keys:", unmatchedAnswerKeys);
      console.log("ðŸ” DEBUG: Unmatched processed IDs:", unmatchedProcessedIds);
      
      // Debug: Show the order of questions and answers
      console.log("ðŸ” DEBUG: Question order:", processedQuestions.map((q, i) => `${i}: ${q.id}`));
      console.log("ðŸ” DEBUG: Answer order:", Object.keys(session.answers || {}).filter(k => k.startsWith('malay-')).sort());
      console.log("ðŸ” DEBUG: First 5 answers:", {
        malay_1: session.answers?.malay_1,
        malay_2: session.answers?.malay_2,
        malay_3: session.answers?.malay_3,
        malay_4: session.answers?.malay_4,
        malay_5: session.answers?.malay_5
      });
      
      // Match questions with answers
      const questionsWithAnswers = processedQuestions.map((question, index) => {
        // The answers are stored as malay-1, malay-2, etc. (sequential)
        // Map the question index to the sequential answer key
        const answerKey = `malay-${index + 1}`;
        let userAnswer = session.answers?.[answerKey] || null;
        
        // Debug: Log available answer keys for first few questions
        if (index < 5) {
          console.log(`ðŸ” DEBUG Question ${question.id} (index ${index}) - Answer key: ${answerKey}`);
          console.log(`ðŸ” DEBUG Question ${question.id} - User answer: ${userAnswer}`);
          console.log(`ðŸ” DEBUG Question ${question.id} - Correct answer: ${question.correctAnswer}`);
        }
        
        const isCorrect = userAnswer === question.correctAnswer;
        
        // Debug: Log the final question object with more details
        if (index < 3) {
          console.log(`ðŸ” DEBUG Final Question ${question.id} (index ${index}):`, {
            answerKey,
            userAnswer,
            correctAnswer: question.correctAnswer,
            isCorrect,
            userAnswerType: typeof userAnswer,
            correctAnswerType: typeof question.correctAnswer,
            questionObject: {
              id: question.id,
              userAnswer,
              isCorrect,
              correctAnswer: question.correctAnswer
            }
          });
        }
        
        return {
          ...question,
          userAnswer,
          isCorrect,
          correctAnswer: question.correctAnswer
        };
      });
      
      setSelectedPosttest({
        participantName: result.participantName,
        participantId: result.participantId,
        category: result.category,
        score: session.score,
        totalQuestions: session.total_questions,
        sessionId: session.id
      });
      
      // Debug: Log the final questions array
      console.log("ðŸ” DEBUG: Final questionsWithAnswers:", questionsWithAnswers.slice(0, 3).map(q => ({
        id: q.id,
        userAnswer: q.userAnswer,
        isCorrect: q.isCorrect,
        correctAnswer: q.correctAnswer
      })));
      
      setPosttestQuestions(questionsWithAnswers);
      setShowPosttestModal(true);
      
    } catch (error) {
      console.error("Error loading posttest details:", error);
    } finally {
      setLoading(false);
    }
  };

  // Process questions from database (similar to PostTestQuestionsScreen for post-test, PreTestQuestionsScreen for pre-test)
  const processQuestionsFromDatabase = (data, isPostTest = false) => {
    if (!data || data.length === 0) return [];
    
    const processedQuestions = [];
    
    for (let i = 0; i < data.length; i++) {
      const question = data[i];
      
      // Validate question has required fields
      if (!question || !question.question_text_en || !question.question_text) {
        console.warn('Skipping invalid question:', question);
        continue;
      }
      
      // Create bilingual question text
      const bilingualText = `${question.question_text}\n${question.question_text_en}`;
      
      // Create bilingual choices
      const bilingualChoices = [];
      const options = ['option_a', 'option_b', 'option_c', 'option_d'];
      const optionsEn = ['option_a_en', 'option_b_en', 'option_c_en', 'option_d_en'];
      
      for (let j = 0; j < 4; j++) {
        const malayOption = question[options[j]];
        const englishOption = question[optionsEn[j]];
        
        if (englishOption && malayOption) {
          bilingualChoices.push(`${malayOption}\n${englishOption}`);
        }
      }
      
      // Only add if we have at least 2 valid choices
      if (bilingualChoices.length >= 2) {
        // Use the same ID format as PostTestQuestionsScreen for post-test questions
        const questionId = isPostTest ? `post-test-${question.id}` : question.id;
        
        processedQuestions.push({
          id: questionId,
          text: bilingualText,
          choices: bilingualChoices,
          correctAnswer: question.correct_option || question.correct_option_en || 'A'
        });
      }
    }
    
    return processedQuestions;
  };

  // Get checklist type display name
  const getChecklistDisplayName = (checklistType) => {
    const names = {
      'one-man-cpr': 'One Man CPR',
      'two-man-cpr': 'Two Man CPR',
      'adult-choking': 'Adult Choking',
      'infant-choking': 'Infant Choking',
      'infant-cpr': 'Infant CPR'
    };
    return names[checklistType] || checklistType;
  };

  // Render checklist details grouped by sections
  const renderChecklistDetails = (checklistType, details) => {
    const sections = getChecklistSections(checklistType);
    
    // Helper function to check if an item was performed
    const isItemPerformed = (itemKey, details, status) => {
      // Handle new structure: {danger_ppe: true, response_shoulder_tap: false, ...}
      if (details[itemKey] !== undefined) {
        return details[itemKey] === true;
      }
      
      // Handle old structure: {performed: [...], notPerformed: [...]}
      if (details.performed && details.notPerformed) {
        // For old structure, if status is PASS, show all items as performed
        // If status is FAIL, show all items as not performed
        return status === 'PASS';
      }
      
      // Default to not performed if structure is unknown
      return false;
    };
    
    return sections.map((section, sectionIndex) => (
      <View key={sectionIndex} style={styles.checklistSection}>
        <Text style={styles.checklistSectionTitle}>{section.title}</Text>
        {section.items.map((item, itemIndex) => {
          const isPerformed = isItemPerformed(item.key, details, selectedChecklist?.status);
          return (
            <View key={itemIndex} style={styles.checklistStepItem}>
              <MaterialCommunityIcons 
                name={isPerformed ? "check-circle" : "close-circle"} 
                size={16} 
                color={isPerformed ? "#28a745" : "#dc3545"} 
              />
              <Text style={styles.checklistStepText}>
                {item.text}: {isPerformed ? "PERFORMED" : "NOT PERFORMED"}
              </Text>
            </View>
          );
        })}
      </View>
    ));
  };

  // Get checklist sections based on type
  const getChecklistSections = (checklistType) => {
    const sections = {
      'one-man-cpr': [
        {
          title: 'DANGER',
          items: [
            { key: 'danger_ppe', text: 'Wear PPE (gloves, apron, mask), look out for hazard' }
          ]
        },
        {
          title: 'RESPONSE',
          items: [
            { key: 'response_shoulder_tap', text: 'a. Shoulder tap' },
            { key: 'response_shout', text: 'b. Shout & speak "are you okay?"' }
          ]
        },
        {
          title: 'SHOUT FOR HELP',
          items: [
            { key: 'shout_emergency', text: 'a. For IHCA - Shout "Emergency! Emergency! Bring the resuscitation trolley and defibrillator/AED!"' }
          ]
        },
        {
          title: 'AIRWAY *Required',
          items: [
            { key: 'airway_head_tilt', text: 'a. Head Tilt Chin Lift' },
            { key: 'airway_jaw_thrust', text: 'b. Jaw Thrust' }
          ]
        },
        {
          title: 'BREATHING *Required',
          items: [
            { key: 'breathing_determine', text: 'a. Determine while opening the airway by looking at the chest, in not more than 10 seconds' },
            { key: 'breathing_compression_begin', text: 'b. Chest compression shall begin with absence of normal breathing or no pulse' }
          ]
        },
        {
          title: 'CIRCULATION *Required',
          items: [
            { key: 'circulation_location', text: 'i. Location - middle of chest, lower half of sternum' },
            { key: 'circulation_rate', text: 'ii. Rate of compression: 100-120/min' },
            { key: 'circulation_depth', text: 'iii. Depth of compression: 5-6 cm' },
            { key: 'circulation_recoil', text: 'iv. Full recoil after each compression' },
            { key: 'circulation_minimize_interruption', text: 'v. Minimize Interruption' },
            { key: 'circulation_ratio', text: 'vi. Compressions to ventilations ratio, 30:2' },
            { key: 'circulation_ventilation_time', text: 'vii. Each ventilation in 1 second' }
          ]
        },
        {
          title: 'DEFIBRILATION',
          items: [
            { key: 'defib_switch_on', text: 'a. Switch on the AED and follow voice prompt' },
            { key: 'defib_attach_pads', text: 'b. Attach the electrode pads' },
            { key: 'defib_clear_analysis', text: 'c. Clear the victim during rhythm analysis' },
            { key: 'defib_clear_shock', text: 'd. If shock is advised, i. Clears the victim and loudly state "Stand Clear"' },
            { key: 'defib_push_shock', text: 'd. If shock is advised, ii. Push shock button as directed' },
            { key: 'defib_resume_cpr', text: 'd. If shock is advised, iii. immediately resume CPR' },
            { key: 'defib_no_shock_continue', text: 'e. If no shock is indicated, continue CPR' }
          ]
        }
      ],
      'adult-choking': [
        {
          title: 'ASSESS SEVERITY',
          items: [
            { key: 'assess_ask_choking', text: 'Ask "Are you choking?"' },
            { key: 'assess_mild_effective_cough', text: 'Mild: Effective cough' },
            { key: 'assess_severe_ineffective_cough', text: 'Severe: Ineffective cough' }
          ]
        },
        {
          title: 'MILD CHOKING',
          items: [
            { key: 'mild_encourage_cough', text: 'Encourage coughing' }
          ]
        },
        {
          title: 'SEVERE CHOKING - BACK BLOWS',
          items: [
            { key: 'severe_5_back_blows', text: '5 back blows' },
            { key: 'severe_lean_victim_forwards', text: 'Lean victim forwards' },
            { key: 'severe_blows_between_shoulder_blades', text: 'Blows between shoulder blades' }
          ]
        },
        {
          title: 'SEVERE CHOKING - ABDOMINAL THRUSTS',
          items: [
            { key: 'severe_5_abdominal_thrusts', text: '5 abdominal thrusts' },
            { key: 'severe_stand_behind_victim', text: 'Stand behind victim' },
            { key: 'severe_arms_around_upper_abdomen', text: 'Arms around upper abdomen' },
            { key: 'severe_leane_victim_forwards_thrusts', text: 'Lean victim forwards for thrusts' },
            { key: 'severe_clench_fist_between_navel_ribcage', text: 'Clench fist between navel and ribcage' },
            { key: 'severe_grasp_fist_pull_sharply', text: 'Grasp fist and pull sharply' },
            { key: 'severe_continue_alternating', text: 'Continue alternating' },
            { key: 'severe_chest_thrust_pregnant_obese', text: 'Chest thrust for pregnant/obese' }
          ]
        },
        {
          title: 'VICTIM UNCONSCIOUS',
          items: [
            { key: 'unconscious_start_cpr', text: 'Start CPR' },
            { key: 'unconscious_check_foreign_body', text: 'Check for foreign body' }
          ]
        }
      ],
      'infant-choking': [
        {
          title: 'ASSESS SEVERITY',
          items: [
            { key: 'assess_mild_loud_cough', text: 'Mild: Loud cough' },
            { key: 'assess_mild_fully_responsive', text: 'Mild: Fully responsive' },
            { key: 'assess_mild_coughing_effectively', text: 'Mild: Coughing effectively' },
            { key: 'assess_mild_still_crying_speaking', text: 'Mild: Still crying/speaking' },
            { key: 'assess_mild_taking_breath_before_coughing', text: 'Mild: Taking breath before coughing' },
            { key: 'assess_severe_cyanosis', text: 'Severe: Cyanosis' },
            { key: 'assess_severe_ineffective_cough', text: 'Severe: Ineffective cough' },
            { key: 'assess_severe_inability_to_cough', text: 'Severe: Inability to cough' },
            { key: 'assess_severe_inability_breathe_vocalise', text: 'Severe: Inability to breathe/vocalise' },
            { key: 'assess_severe_decreasing_consciousness', text: 'Severe: Decreasing consciousness' }
          ]
        },
        {
          title: 'MILD CHOKING',
          items: [
            { key: 'mild_encourage_cough_monitor', text: 'Encourage coughing and monitor' }
          ]
        },
        {
          title: 'SEVERE CHOKING - BACK BLOWS',
          items: [
            { key: 'severe_ask_for_help', text: 'Ask for help' },
            { key: 'severe_mobile_phone_speaker', text: 'Mobile phone on speaker' },
            { key: 'severe_perform_5_back_blows', text: 'Perform 5 back blows' },
            { key: 'severe_back_blows_support_infant', text: 'Support infant for back blows' },
            { key: 'severe_back_blows_head_downwards_prone', text: 'Head downwards, prone position' },
            { key: 'severe_back_blows_thumb_angle_lower_jaw', text: 'Thumb angle lower jaw' },
            { key: 'severe_back_blows_heel_middle_back', text: 'Heel of hand middle of back' },
            { key: 'severe_back_blows_between_shoulder_blades', text: 'Between shoulder blades' }
          ]
        },
        {
          title: 'SEVERE CHOKING - CHEST THRUSTS',
          items: [
            { key: 'severe_perform_5_chest_thrusts', text: 'Perform 5 chest thrusts' },
            { key: 'severe_chest_thrust_turn_supine', text: 'Turn to supine position' },
            { key: 'severe_chest_thrust_lower_sternum', text: 'Lower half of sternum' },
            { key: 'severe_chest_thrust_encircle_occiput', text: 'Encircle occiput' },
            { key: 'severe_chest_thrust_identify_landmark', text: 'Identify landmark' },
            { key: 'severe_chest_thrust_free_arm_along_back', text: 'Free arm along back' },
            { key: 'severe_chest_thrust_head_downwards_supine', text: 'Head downwards, supine' },
            { key: 'severe_chest_thrust_finger_breadth_above_xiphisternum', text: 'Finger breadth above xiphisternum' }
          ]
        },
        {
          title: 'SEQUENCE MANAGEMENT',
          items: [
            { key: 'severe_single_rescuer_proceed', text: 'Single rescuer proceed' },
            { key: 'severe_second_rescuer_call_mers', text: 'Second rescuer call MERS' },
            { key: 'severe_single_rescuer_call_simultaneously', text: 'Single rescuer call simultaneously' },
            { key: 'severe_continue_sequence_foreign_body', text: 'Continue sequence foreign body' },
            { key: 'severe_continue_sequence_still_conscious', text: 'Continue sequence still conscious' }
          ]
        },
        {
          title: 'UNCONSCIOUS VICTIM',
          items: [
            { key: 'unconscious_start_cpr', text: 'Start CPR' },
            { key: 'unconscious_check_foreign_body', text: 'Check for foreign body' },
            { key: 'unconscious_no_blind_finger_sweep', text: 'No blind finger sweep' },
            { key: 'unconscious_reposition_head_no_chest_rise', text: 'Reposition head, no chest rise' }
          ]
        }
      ],
      'infant-cpr': [
        {
          title: 'DANGER',
          items: [
            { key: 'danger_ppe', text: 'Wear PPE (gloves, apron, mask), look out for hazard' }
          ]
        },
        {
          title: 'RESPONSE',
          items: [
            { key: 'response_tap_soles', text: 'Tap soles of feet' },
            { key: 'response_shout_call_infant', text: 'Shout & call infant' }
          ]
        },
        {
          title: 'SHOUT FOR HELP',
          items: [
            { key: 'shout_emergency', text: 'Shout "Emergency! Emergency! Bring the resuscitation trolley and defibrillator/AED!"' }
          ]
        },
        {
          title: 'AIRWAY',
          items: [
            { key: 'airway_head_tilt_chin_lift', text: 'Head Tilt Chin Lift' },
            { key: 'airway_jaw_thrust', text: 'Jaw Thrust' }
          ]
        },
        {
          title: 'BREATHING',
          items: [
            { key: 'breathing_look_normal_breathing', text: 'Look for normal breathing' },
            { key: 'breathing_absent_abnormal', text: 'Absent/abnormal breathing' },
            { key: 'breathing_5_initial_rescue_breaths', text: '5 initial rescue breaths' },
            { key: 'breathing_duration_1_second', text: 'Duration 1 second' },
            { key: 'breathing_visible_chest_rise', text: 'Visible chest rise' }
          ]
        },
        {
          title: 'CIRCULATION',
          items: [
            { key: 'circulation_assess_circulation', text: 'Assess circulation' },
            { key: 'circulation_brachial_pulse_10_seconds', text: 'Brachial pulse 10 seconds' },
            { key: 'circulation_start_compression_no_signs', text: 'Start compression no signs' },
            { key: 'circulation_start_compression_pulse_less_60', text: 'Start compression pulse < 60' },
            { key: 'circulation_one_rescuer_2_fingers', text: 'One rescuer 2 fingers' },
            { key: 'circulation_two_rescuers_two_thumbs', text: 'Two rescuers two thumbs' },
            { key: 'circulation_site_lower_half_sternum', text: 'Site lower half sternum' },
            { key: 'circulation_depth_1_3_chest_4cm', text: 'Depth 1/3 chest 4cm' },
            { key: 'circulation_rate_100_120_per_min', text: 'Rate 100-120 per min' },
            { key: 'circulation_ratio_15_2', text: 'Ratio 15:2' },
            { key: 'circulation_recovery_position_lateral', text: 'Recovery position lateral' }
          ]
        }
      ],
      'two-man-cpr': [
        {
          title: 'DANGER - 1st Rescuer',
          items: [
            { key: 'danger_ppe_1st', text: 'Wear PPE (gloves, apron, mask), look out for hazard' }
          ]
        },
        {
          title: 'RESPONSE - 1st Rescuer',
          items: [
            { key: 'response_shoulder_tap_1st', text: 'Shoulder tap' },
            { key: 'response_shout_1st', text: 'Shout & speak "are you okay?"' }
          ]
        },
        {
          title: 'SHOUT FOR HELP - 1st Rescuer',
          items: [
            { key: 'shout_emergency_1st', text: 'Shout "Emergency! Emergency! Bring the resuscitation trolley and defibrillator/AED!"' }
          ]
        },
        {
          title: 'AIRWAY - 1st Rescuer',
          items: [
            { key: 'airway_head_tilt_1st', text: 'Head Tilt Chin Lift' },
            { key: 'airway_jaw_thrust_1st', text: 'Jaw Thrust' }
          ]
        },
        {
          title: 'BREATHING - 1st Rescuer',
          items: [
            { key: 'breathing_determine_1st', text: 'Determine breathing' },
            { key: 'breathing_compression_begin_1st', text: 'Compression begin' }
          ]
        },
        {
          title: 'CIRCULATION - 1st Rescuer (High Quality CPR)',
          items: [
            { key: 'circulation_location_1st', text: 'Location - middle of chest' },
            { key: 'circulation_rate_1st', text: 'Rate 100-120/min' },
            { key: 'circulation_depth_1st', text: 'Depth 5-6 cm' },
            { key: 'circulation_recoil_1st', text: 'Full recoil' },
            { key: 'circulation_minimize_interruption_1st', text: 'Minimize interruption' },
            { key: 'circulation_ratio_1st', text: 'Ratio 30:2' },
            { key: 'circulation_ventilation_time_1st', text: 'Ventilation time' }
          ]
        },
        {
          title: 'DEFIBRILATION - 2nd Rescuer',
          items: [
            { key: 'defib_arrives_turns_on', text: 'Arrives and turns on' },
            { key: 'defib_attach_pads_while_compression', text: 'Attach pads while compression' },
            { key: 'defib_clear_analysis_switch_roles', text: 'Clear analysis switch roles' },
            { key: 'defib_clear_shock', text: 'Clear shock' }
          ]
        }
      ]
    };

    return sections[checklistType] || [];
  };

  // Render status button
  const renderStatusButton = (isPassed, result, checklistType) => {
    // Check if this checklist was actually taken by looking at the latestResults
    const hasChecklistData = result.latestResults && result.latestResults[checklistType] && 
                            result.latestResults[checklistType].status;
    
    if (!hasChecklistData) {
      return (
        <View style={[styles.statusButton, { backgroundColor: "#6c757d" }]}>
          <Text style={styles.statusText}>N/A</Text>
        </View>
      );
    }
    
    return (
      <TouchableOpacity 
        style={[styles.statusButton, { backgroundColor: isPassed ? "#28a745" : "#dc3545" }]}
        onPress={() => viewChecklistDetails(result, checklistType)}
        activeOpacity={0.7}
      >
        <Text style={styles.statusText}>{isPassed ? "PASS" : "FAIL"}</Text>
      </TouchableOpacity>
    );
  };

  // Render remedial status
  const renderRemedialStatus = (postTestScore, category = 'non-clinical') => {
    const isAllowed = calculateRemedialAllowed(postTestScore, category);
    return (
      <Text style={[styles.remedialText, { color: isAllowed ? "#00FFFF" : "#DC143C" }]}>
        {isAllowed ? "ALLOW" : "NOT ALLOW"}
      </Text>
    );
  };

  // Show certificate for certified participants
  const handleShowCertificate = (result) => {
    console.log("ðŸ” DEBUG: handleShowCertificate called with result:", result);
    const isCertified = calculateCertified(result);
    console.log("ðŸ” DEBUG: isCertified:", isCertified);
    
    if (!isCertified) {
      console.log("ðŸ” DEBUG: Participant not certified, showing alert");
      Alert.alert("Not Eligible", "This participant has not completed the BLS Course requirements.");
      return;
    }

    console.log("ðŸ” DEBUG: Setting certificate data and showing certificate");
    setCertificateData({
      participantName: result.participantName,
      participantId: result.participantId,
      completionDate: result.date
    });
    setShowCertificate(true);
    console.log("ðŸ” DEBUG: showCertificate set to true");
  };

  // Render certified status with certificate generation
  const renderCertifiedStatus = (result) => {
    const isCertified = calculateCertified(result);
    console.log("ðŸ” DEBUG: renderCertifiedStatus for", result.participantName, "isCertified:", isCertified);
    
    if (isCertified === null) {
      return (
        <View style={[styles.statusButton, { backgroundColor: "#6c757d" }]}>
          <Text style={styles.statusText}>N/A</Text>
        </View>
      );
    }
    
    if (isCertified) {
      console.log("ðŸ” DEBUG: Rendering CERT button for", result.participantName);
      return (
        <TouchableOpacity 
          style={[styles.certificateButton, { backgroundColor: "#28a745" }]}
          onPress={() => {
            console.log("ðŸ” DEBUG: CERT button pressed for", result.participantName);
            handleShowCertificate(result);
          }}
          activeOpacity={0.7}
        >
          <MaterialCommunityIcons name="certificate" size={16} color="#ffffff" />
          <Text style={styles.certificateButtonText}>CERT</Text>
        </TouchableOpacity>
      );
    }
    
    return (
      <View style={[styles.statusButton, { backgroundColor: "#dc3545" }]}>
        <Text style={styles.statusText}>NO</Text>
      </View>
    );
  };

  // If showing certificate, render it as a full screen
  console.log("ðŸ” DEBUG: BLSResultsScreen render - showCertificate:", showCertificate, "certificateData:", certificateData);
  if (showCertificate && certificateData) {
    console.log("ðŸ” DEBUG: Rendering CertificateScreen");
    return (
      <CertificateScreen 
        participantData={certificateData}
        onBack={() => setShowCertificate(false)}
      />
    );
  }

  return (
    <LuxuryShell title="BLS Results - All Participants" onSignOut={onSignOut} onBack={onBack}>
      <View style={styles.container}>
        {/* Tab Navigation */}
        <View style={styles.tabContainer}>
          <TouchableOpacity
            style={[styles.tab, activeTab === 'all' && styles.activeTab]}
            onPress={() => setActiveTab('all')}
          >
            <Text style={[styles.tabText, activeTab === 'all' && styles.activeTabText]}>
              ALL RESULTS
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.tab, activeTab === 'dashboard' && styles.activeTab]}
            onPress={() => setActiveTab('dashboard')}
          >
            <Text style={[styles.tabText, activeTab === 'dashboard' && styles.activeTabText]}>
              DASHBOARD
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.tab, activeTab === 'pretest' && styles.activeTab]}
            onPress={() => setActiveTab('pretest')}
          >
            <Text style={[styles.tabText, activeTab === 'pretest' && styles.activeTabText]}>
              PRE TEST STATS
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.tab, activeTab === 'posttest' && styles.activeTab]}
            onPress={() => setActiveTab('posttest')}
          >
            <Text style={[styles.tabText, activeTab === 'posttest' && styles.activeTabText]}>
              POST TEST STATS
            </Text>
          </TouchableOpacity>
        </View>

        {/* Search and Filter Controls */}
        {(activeTab === 'all' || activeTab === 'pretest' || activeTab === 'posttest') && (
          <View style={styles.controlsContainer}>
            {activeTab === 'all' && (
              <View style={styles.searchContainer}>
                <MaterialCommunityIcons name="magnify" size={20} color="#8a7f6a" style={styles.searchIcon} />
                <TextInput
                  style={styles.searchInput}
                  placeholder="Search participants..."
                  placeholderTextColor="#8a7f6a"
                  value={searchQuery}
                  onChangeText={setSearchQuery}
                />
                {searchQuery.length > 0 && (
                  <TouchableOpacity onPress={() => setSearchQuery('')} style={styles.clearButton}>
                    <MaterialCommunityIcons name="close-circle" size={20} color="#8a7f6a" />
                  </TouchableOpacity>
                )}
              </View>
            )}
            
            <TouchableOpacity
              style={styles.dateFilterButton}
              onPress={() => setShowDatePicker(true)}
            >
              <MaterialCommunityIcons name="calendar" size={16} color="#00ffc8" />
              <Text style={styles.dateFilterText}>
                {dateFilterType === 'all' && 'All Time'}
                {dateFilterType === 'today' && 'Today'}
                {dateFilterType === '7days' && 'Last 7 Days'}
                {dateFilterType === '30days' && 'Last 30 Days'}
                {dateFilterType === 'custom' && dateFilter && new Date(dateFilter).toLocaleDateString()}
                {dateFilterType === 'custom' && !dateFilter && 'Custom Date'}
              </Text>
              <MaterialCommunityIcons name="chevron-down" size={16} color="#00ffc8" style={styles.dropdownIcon} />
            </TouchableOpacity>
            
            {activeTab === 'all' && (
              <TouchableOpacity
                style={styles.exportButton}
                onPress={exportToCSV}
              >
                <MaterialCommunityIcons name="download" size={16} color="#00ffc8" />
                <Text style={styles.exportButtonText}>Export CSV</Text>
              </TouchableOpacity>
            )}
          </View>
        )}

        {/* Pagination Controls */}
        {activeTab === 'all' && getFilteredResults().length > 0 && (
          <View style={styles.paginationControls}>
            <View style={styles.resultsPerPageContainer}>
              <Text style={styles.resultsPerPageLabel}>Show:</Text>
              <View style={styles.resultsPerPageButtons}>
                {[20, 50, 100].map((count) => (
                  <TouchableOpacity
                    key={count}
                    style={[
                      styles.resultsPerPageButton,
                      resultsPerPage === count && styles.resultsPerPageButtonActive
                    ]}
                    onPress={() => handleResultsPerPageChange(count)}
                  >
                    <Text style={[
                      styles.resultsPerPageButtonText,
                      resultsPerPage === count && styles.resultsPerPageButtonTextActive
                    ]}>
                      {count}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
            
            {getTotalPages() > 1 && (
              <View style={styles.pageNavigation}>
                <TouchableOpacity
                  style={[styles.pageButton, currentPage === 1 && styles.pageButtonDisabled]}
                  onPress={() => handlePageChange(currentPage - 1)}
                  disabled={currentPage === 1}
                >
                  <MaterialCommunityIcons name="chevron-left" size={16} color={currentPage === 1 ? "#6c757d" : "#00ffc8"} />
                </TouchableOpacity>
                
                <Text style={styles.pageInfo}>
                  {currentPage}/{getTotalPages()}
                </Text>
                
                <TouchableOpacity
                  style={[styles.pageButton, currentPage === getTotalPages() && styles.pageButtonDisabled]}
                  onPress={() => handlePageChange(currentPage + 1)}
                  disabled={currentPage === getTotalPages()}
                >
                  <MaterialCommunityIcons name="chevron-right" size={16} color={currentPage === getTotalPages() ? "#6c757d" : "#00ffc8"} />
                </TouchableOpacity>
              </View>
            )}
          </View>
        )}

        {/* Summary Header */}
        {getFilteredResults().length > 0 && (
          <View style={styles.summaryHeader}>
            <Text style={styles.summaryText}>
              {activeTab === 'all' && `Total Participants: ${getFilteredResults().length}`}
              {activeTab === 'pretest' && `Pre-Test Participants: ${getNewDashboardStats().passFailStats.preTest.total}`}
              {activeTab === 'posttest' && `Post-Test Participants: ${getNewDashboardStats().passFailStats.postTest.total}`}
              {searchQuery && ` (filtered by "${searchQuery}")`}
              {dateFilterType === 'today' && ' (Today)'}
              {dateFilterType === '7days' && ' (Last 7 days)'}
              {dateFilterType === 'custom' && dateFilter && ` (${new Date(dateFilter).toLocaleDateString()})`}
            </Text>
            {activeTab === 'all' && (
              <Text style={styles.paginationInfo}>
                Showing {((currentPage - 1) * resultsPerPage) + 1}-{Math.min(currentPage * resultsPerPage, getFilteredResults().length)} of {getFilteredResults().length}
              </Text>
            )}
          </View>
        )}
        {loading && !refreshing && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#e9ddc4" />
            <Text style={styles.loadingText}>Loading results...</Text>
          </View>
        )}
        
        {error ? (
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{error}</Text>
            <TouchableOpacity style={styles.retryButton} onPress={loadResults}>
              <Text style={styles.retryButtonText}>Retry</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <>
            {activeTab === 'dashboard' ? (
              // Dashboard Tab
              <ScrollView
                style={styles.scrollView}
                contentContainerStyle={styles.scrollViewContent}
                refreshControl={
                  <RefreshControl refreshing={refreshing} onRefresh={onRefresh} tintColor="#e9ddc4" />
                }
              >
                <View style={styles.dashboardContainer}>
                  {/* Modern Header */}
                  <View style={styles.modernHeader}>
                    <View style={styles.headerContent}>
                      <View style={styles.logoContainer}>
                        <View style={styles.logoIcon}>
                          <MaterialCommunityIcons name="chart-line-variant" size={28} color="#8B5CF6" />
                        </View>
                        <Text style={styles.modernTitle}>BLS Analytics</Text>
                      </View>
                      <View style={styles.headerActions}>
                        <TouchableOpacity style={styles.headerButton}>
                          <MaterialCommunityIcons name="refresh" size={20} color="#6B7280" />
                        </TouchableOpacity>
                        <TouchableOpacity style={styles.headerButton}>
                          <MaterialCommunityIcons name="cog" size={20} color="#6B7280" />
                        </TouchableOpacity>
                      </View>
                    </View>
                    <Text style={styles.modernSubtitle}>Real-time performance insights and analytics</Text>
                  </View>

                  {getFilteredResults().length === 0 ? (
                    <View style={styles.emptyState}>
                      <View style={styles.emptyIconContainer}>
                        <MaterialCommunityIcons name="chart-line" size={48} color="#8B5CF6" />
                      </View>
                      <Text style={styles.emptyTitle}>No Data Available</Text>
                      <Text style={styles.emptyDescription}>
                        Start collecting BLS training data to see analytics here
                      </Text>
                    </View>
                  ) : (
                    <View style={styles.modernContent}>
                      {/* Key Metrics Row */}
                      <View style={styles.metricsRow}>
                        <TouchableOpacity 
                          style={[styles.metricCard, styles.primaryCard, styles.clickableCard]}
                          onPress={() => handleMetricCardClick('Clinical Staff', 'clinical')}
                          activeOpacity={0.8}
                        >
                          <View style={styles.metricIconContainer}>
                            <MaterialCommunityIcons name="medical-bag" size={24} color="#8B5CF6" />
                          </View>
                          <Text style={styles.metricValue}>{getDashboardStats().clinical.count}</Text>
                          <Text style={styles.metricLabel}>Clinical Staff</Text>
                          <View style={styles.metricTrend}>
                            <MaterialCommunityIcons name="trending-up" size={16} color="#10B981" />
                            <Text style={styles.trendText}>+{getDashboardStats().clinical.percentage}%</Text>
                          </View>
                          <View style={styles.clickIndicator}>
                            <MaterialCommunityIcons name="chevron-right" size={16} color="rgba(255, 255, 255, 0.5)" />
                          </View>
                        </TouchableOpacity>

                        <TouchableOpacity 
                          style={[styles.metricCard, styles.secondaryCard, styles.clickableCard]}
                          onPress={() => handleMetricCardClick('Non-Clinical Staff', 'non-clinical')}
                          activeOpacity={0.8}
                        >
                          <View style={styles.metricIconContainer}>
                            <MaterialCommunityIcons name="account-group" size={24} color="#F59E0B" />
                          </View>
                          <Text style={styles.metricValue}>{getDashboardStats().nonClinical.count}</Text>
                          <Text style={styles.metricLabel}>Non-Clinical</Text>
                          <View style={styles.metricTrend}>
                            <MaterialCommunityIcons name="trending-up" size={16} color="#10B981" />
                            <Text style={styles.trendText}>+{getDashboardStats().nonClinical.percentage}%</Text>
                          </View>
                          <View style={styles.clickIndicator}>
                            <MaterialCommunityIcons name="chevron-right" size={16} color="rgba(255, 255, 255, 0.5)" />
                          </View>
                        </TouchableOpacity>

                        <TouchableOpacity 
                          style={[styles.metricCard, styles.successCard, styles.clickableCard]}
                          onPress={() => handleMetricCardClick('Pre-Test Pass', 'pre-test-pass')}
                          activeOpacity={0.8}
                        >
                          <View style={styles.metricIconContainer}>
                            <MaterialCommunityIcons name="check-circle" size={24} color="#10B981" />
                          </View>
                          <Text style={styles.metricValue}>{getDashboardStats().preTestPass.count}</Text>
                          <Text style={styles.metricLabel}>Pre-Test Pass</Text>
                          <View style={styles.metricTrend}>
                            <MaterialCommunityIcons name="trending-up" size={16} color="#10B981" />
                            <Text style={styles.trendText}>+{getDashboardStats().preTestPass.percentage}%</Text>
                          </View>
                          <View style={styles.clickIndicator}>
                            <MaterialCommunityIcons name="chevron-right" size={16} color="rgba(255, 255, 255, 0.5)" />
                          </View>
                        </TouchableOpacity>

                        <TouchableOpacity 
                          style={[styles.metricCard, styles.warningCard, styles.clickableCard]}
                          onPress={() => handleMetricCardClick('Remedial Allowed', 'remedial-allowed')}
                          activeOpacity={0.8}
                        >
                          <View style={styles.metricIconContainer}>
                            <MaterialCommunityIcons name="school" size={24} color="#3B82F6" />
                          </View>
                          <Text style={styles.metricValue}>{getDashboardStats().remedialAllowed.count}</Text>
                          <Text style={styles.metricLabel}>Remedial Allowed</Text>
                          <View style={styles.metricTrend}>
                            <MaterialCommunityIcons name="trending-up" size={16} color="#10B981" />
                            <Text style={styles.trendText}>+{getDashboardStats().remedialAllowed.percentage}%</Text>
                          </View>
                          <View style={styles.clickIndicator}>
                            <MaterialCommunityIcons name="chevron-right" size={16} color="rgba(255, 255, 255, 0.5)" />
                          </View>
                        </TouchableOpacity>
                      </View>

                      {/* Performance Overview */}
                      <View style={styles.overviewSection}>
                        <View style={styles.sectionHeader}>
                          <Text style={styles.sectionTitle}>Performance Overview</Text>
                          {results.length > 0 && (
                            <View style={styles.sectionActions}>
                              <TouchableOpacity 
                                style={styles.dateFilterButton}
                                onPress={() => setShowDatePicker(true)}
                              >
                                <MaterialCommunityIcons name="calendar" size={16} color="#00ffc8" />
                                <Text style={styles.dateFilterText}>
                                  {dateFilterType === 'all' && 'All Time'}
                                  {dateFilterType === 'today' && 'Today'}
                                  {dateFilterType === '7days' && 'Last 7 Days'}
                                  {dateFilterType === '30days' && 'Last 30 Days'}
                                  {dateFilterType === 'custom' && dateFilter && new Date(dateFilter).toLocaleDateString()}
                                  {dateFilterType === 'custom' && !dateFilter && 'Custom Date'}
                                </Text>
                                <MaterialCommunityIcons name="chevron-down" size={16} color="#00ffc8" style={styles.dropdownIcon} />
                              </TouchableOpacity>
                            </View>
                          )}
                        </View>

                        {/* Date Filter Status Indicator */}
                        {results.length > 0 && (
                          <View style={styles.dateFilterStatus}>
                            <MaterialCommunityIcons name="calendar-clock" size={16} color="#00ffc8" />
                            <Text style={styles.dateFilterStatusText}>
                              {dateFilterType === 'all' && 'Showing all time data'}
                              {dateFilterType === 'today' && 'Showing today\'s data'}
                              {dateFilterType === '7days' && 'Showing last 7 days data'}
                              {dateFilterType === '30days' && 'Showing last 30 days data'}
                              {dateFilterType === 'custom' && dateFilter && `Showing data for ${new Date(dateFilter).toLocaleDateString()}`}
                              {dateFilterType === 'custom' && !dateFilter && 'Select custom date'}
                            </Text>
                          </View>
                        )}

                        {results.length === 0 ? (
                          <View style={styles.noDataContainer}>
                            <MaterialCommunityIcons name="chart-line" size={48} color="#8a7f6a" />
                            <Text style={styles.noDataTitle}>No Data Available</Text>
                            <Text style={styles.noDataDescription}>
                              No participants have completed BLS training yet. Data will appear here once participants start taking tests.
                            </Text>
                          </View>
                        ) : (
                          <View style={styles.overviewCards}>
                            <View style={styles.overviewCard}>
                              <View style={styles.overviewHeader}>
                                <Text style={styles.overviewTitle}>Test Performance</Text>
                                <View style={styles.statusIndicator}>
                                  <View style={[styles.statusDot, { backgroundColor: '#10B981' }]} />
                                  <Text style={styles.statusText}>Active</Text>
                                </View>
                              </View>
                            <View style={styles.overviewStats}>
                              {/* Pre-Test Statistics */}
                              <View style={styles.testStatsContainer}>
                                <Text style={styles.testTitle}>Pre-Test</Text>
                                <View style={styles.statsRow}>
                                  <TouchableOpacity 
                                    style={[styles.statCard, styles.passCard]}
                                    onPress={() => handleTestStatClick('pre-test-pass')}
                                    activeOpacity={0.8}
                                  >
                                    <View style={styles.statHeader}>
                                      <MaterialCommunityIcons name="check-circle" size={20} color="#10B981" />
                                      <Text style={styles.statLabel}>Pass</Text>
                                    </View>
                                    <Text style={styles.statNumber}>{getDashboardStats().preTestPass.count}</Text>
                                    <Text style={styles.statPercentage}>{getDashboardStats().preTestPass.percentage}%</Text>
                                  </TouchableOpacity>
                                  
                                  <TouchableOpacity 
                                    style={[styles.statCard, styles.failCard]}
                                    onPress={() => handleTestStatClick('pre-test-fail')}
                                    activeOpacity={0.8}
                                  >
                                    <View style={styles.statHeader}>
                                      <MaterialCommunityIcons name="close-circle" size={20} color="#EF4444" />
                                      <Text style={styles.statLabel}>Fail</Text>
                                    </View>
                                    <Text style={styles.statNumber}>{getDashboardStats().preTestFail.count}</Text>
                                    <Text style={styles.statPercentage}>{getDashboardStats().preTestFail.percentage}%</Text>
                                  </TouchableOpacity>
                                </View>
                              </View>

                              {/* Post-Test Statistics */}
                              <View style={styles.testStatsContainer}>
                                <Text style={styles.testTitle}>Post-Test</Text>
                                <View style={styles.statsRow}>
                                  <TouchableOpacity 
                                    style={[styles.statCard, styles.passCard]}
                                    onPress={() => handleTestStatClick('post-test-pass')}
                                    activeOpacity={0.8}
                                  >
                                    <View style={styles.statHeader}>
                                      <MaterialCommunityIcons name="check-circle" size={20} color="#10B981" />
                                      <Text style={styles.statLabel}>Pass</Text>
                                    </View>
                                    <Text style={styles.statNumber}>{getDashboardStats().postTestPass.count}</Text>
                                    <Text style={styles.statPercentage}>{getDashboardStats().postTestPass.percentage}%</Text>
                                  </TouchableOpacity>
                                  
                                  <TouchableOpacity 
                                    style={[styles.statCard, styles.failCard]}
                                    onPress={() => handleTestStatClick('post-test-fail')}
                                    activeOpacity={0.8}
                                  >
                                    <View style={styles.statHeader}>
                                      <MaterialCommunityIcons name="close-circle" size={20} color="#EF4444" />
                                      <Text style={styles.statLabel}>Fail</Text>
                                    </View>
                                    <Text style={styles.statNumber}>{getDashboardStats().postTestFail.count}</Text>
                                    <Text style={styles.statPercentage}>{getDashboardStats().postTestFail.percentage}%</Text>
                                  </TouchableOpacity>
                                </View>
                              </View>
                            </View>
                          </View>

                          <View style={styles.overviewCard}>
                            <View style={styles.overviewHeader}>
                              <Text style={styles.overviewTitle}>Certification Status</Text>
                              <View style={styles.statusIndicator}>
                                <View style={[styles.statusDot, { backgroundColor: '#8B5CF6' }]} />
                                <Text style={styles.statusText}>Processing</Text>
                              </View>
                            </View>
                            <View style={styles.certificationStats}>
                              <View style={styles.certificationItem}>
                                <Text style={styles.certificationLabel}>Eligible</Text>
                                <Text style={styles.certificationValue}>{getDashboardStats().certifiedEligible.count}</Text>
                              </View>
                              <View style={styles.certificationItem}>
                                <Text style={styles.certificationLabel}>Not Eligible</Text>
                                <Text style={styles.certificationValue}>{getDashboardStats().certifiedNotEligible.count}</Text>
                              </View>
                            </View>
                          </View>
                        </View>
                        )}
                      </View>

                      {/* Professional Charts Section */}
                      <View style={styles.chartsSection}>
                        <Text style={styles.sectionTitle}>Performance Analytics</Text>
                        
                        {/* Donut Charts Row */}
                        <View style={styles.chartsRow}>
                          {/* Pre-Test Donut Chart */}
                          <View style={styles.donutChartContainer}>
                            <View style={styles.donutChartHeader}>
                              <Text style={styles.donutChartTitle}>Pre-Test</Text>
                              <View style={styles.donutChartActions}>
                                <TouchableOpacity style={styles.chartActionButton}>
                                  <MaterialCommunityIcons name="information" size={14} color="rgba(255, 255, 255, 0.7)" />
                                </TouchableOpacity>
                              </View>
                            </View>
                            <View style={styles.donutChartWrapper}>
                              <View style={styles.donutChart}>
                                <View style={styles.donutChartInner}>
                                  <Text style={styles.donutChartPercentage}>{getDashboardStats().preTestPass.percentage}%</Text>
                                  <Text style={styles.donutChartLabel}>Success</Text>
                                </View>
                                <View style={styles.donutChartRing}>
                                  <View 
                                    style={[
                                      styles.donutChartSegment, 
                                      { 
                                        transform: [{ rotate: `${(getDashboardStats().preTestPass.percentage * 3.6)}deg` }],
                                        backgroundColor: '#34D399'
                                      }
                                    ]} 
                                  />
                                </View>
                              </View>
                            </View>
                            <View style={styles.donutChartStats}>
                              <View style={styles.donutStatItem}>
                                <View style={[styles.donutStatDot, { backgroundColor: '#34D399' }]} />
                                <Text style={styles.donutStatText}>{getDashboardStats().preTestPass.count} Pass</Text>
                              </View>
                              <View style={styles.donutStatItem}>
                                <View style={[styles.donutStatDot, { backgroundColor: '#EF4444' }]} />
                                <Text style={styles.donutStatText}>{getDashboardStats().preTestFail.count} Fail</Text>
                              </View>
                            </View>
                          </View>

                          {/* Post-Test Donut Chart */}
                          <View style={styles.donutChartContainer}>
                            <View style={styles.donutChartHeader}>
                              <Text style={styles.donutChartTitle}>Post-Test</Text>
                              <View style={styles.donutChartActions}>
                                <TouchableOpacity style={styles.chartActionButton}>
                                  <MaterialCommunityIcons name="information" size={14} color="rgba(255, 255, 255, 0.7)" />
                                </TouchableOpacity>
                              </View>
                            </View>
                            <View style={styles.donutChartWrapper}>
                              <View style={styles.donutChart}>
                                <View style={styles.donutChartInner}>
                                  <Text style={styles.donutChartPercentage}>{getDashboardStats().postTestPass.percentage}%</Text>
                                  <Text style={styles.donutChartLabel}>Success</Text>
                                </View>
                                <View style={styles.donutChartRing}>
                                  <View 
                                    style={[
                                      styles.donutChartSegment, 
                                      { 
                                        transform: [{ rotate: `${(getDashboardStats().postTestPass.percentage * 3.6)}deg` }],
                                        backgroundColor: '#60A5FA'
                                      }
                                    ]} 
                                  />
                                </View>
                              </View>
                            </View>
                            <View style={styles.donutChartStats}>
                              <View style={styles.donutStatItem}>
                                <View style={[styles.donutStatDot, { backgroundColor: '#60A5FA' }]} />
                                <Text style={styles.donutStatText}>{getDashboardStats().postTestPass.count} Pass</Text>
                              </View>
                              <View style={styles.donutStatItem}>
                                <View style={[styles.donutStatDot, { backgroundColor: '#EF4444' }]} />
                                <Text style={styles.donutStatText}>{getDashboardStats().postTestFail.count} Fail</Text>
                              </View>
                            </View>
                          </View>
                        </View>

                        {/* Area Chart */}
                        <View style={styles.chartContainer}>
                          <View style={styles.chartHeader}>
                            <Text style={styles.chartTitle}>Performance Trends</Text>
                            <View style={styles.chartActions}>
                              <TouchableOpacity style={styles.chartActionButton}>
                                <MaterialCommunityIcons name="trending-up" size={16} color="rgba(255, 255, 255, 0.7)" />
                              </TouchableOpacity>
                              <TouchableOpacity style={styles.chartActionButton}>
                                <MaterialCommunityIcons name="download" size={16} color="rgba(255, 255, 255, 0.7)" />
                              </TouchableOpacity>
                            </View>
                          </View>
                          
                          <View style={styles.areaChartContainer}>
                            <View style={styles.areaChartYAxis}>
                              <Text style={styles.areaChartYLabel}>100%</Text>
                              <Text style={styles.areaChartYLabel}>75%</Text>
                              <Text style={styles.areaChartYLabel}>50%</Text>
                              <Text style={styles.areaChartYLabel}>25%</Text>
                              <Text style={styles.areaChartYLabel}>0%</Text>
                            </View>
                            
                            <View style={styles.areaChartContent}>
                              <View style={styles.areaChartGrid}>
                                <View style={styles.areaChartGridLine} />
                                <View style={styles.areaChartGridLine} />
                                <View style={styles.areaChartGridLine} />
                                <View style={styles.areaChartGridLine} />
                              </View>
                              
                              <View style={styles.areaChartArea}>
                                <View style={styles.areaChartPath}>
                                  <View style={styles.areaChartFill} />
                                </View>
                                <View style={styles.areaChartLine} />
                                <View style={styles.areaChartDots}>
                                  <View style={[styles.areaChartDot, { left: '10%', top: `${100 - getDashboardStats().preTestPass.percentage}%` }]} />
                                  <View style={[styles.areaChartDot, { left: '50%', top: `${100 - getDashboardStats().postTestPass.percentage}%` }]} />
                                  <View style={[styles.areaChartDot, { left: '90%', top: `${100 - getDashboardStats().certifiedEligible.percentage}%` }]} />
                                </View>
                              </View>
                              
                              <View style={styles.areaChartXAxis}>
                                <Text style={styles.areaChartXLabel}>Pre-Test</Text>
                                <Text style={styles.areaChartXLabel}>Post-Test</Text>
                                <Text style={styles.areaChartXLabel}>Certification</Text>
                              </View>
                            </View>
                          </View>
                        </View>

                        {/* Gauge Charts Row */}
                        <View style={styles.chartsRow}>
                          {/* Clinical vs Non-Clinical Gauge */}
                          <View style={styles.gaugeChartContainer}>
                            <View style={styles.gaugeChartHeader}>
                              <Text style={styles.gaugeChartTitle}>Staff Distribution</Text>
                              <MaterialCommunityIcons name="account-group" size={20} color="#93C5FD" />
                            </View>
                            <View style={styles.gaugeChartWrapper}>
                              <View style={styles.gaugeChart}>
                                <View style={styles.gaugeChartArc}>
                                  <View 
                                    style={[
                                      styles.gaugeChartFill, 
                                      { 
                                        transform: [{ rotate: `${(getDashboardStats().clinical.percentage * 1.8) - 90}deg` }],
                                        backgroundColor: '#93C5FD'
                                      }
                                    ]} 
                                  />
                                </View>
                                <View style={styles.gaugeChartCenter}>
                                  <Text style={styles.gaugeChartValue}>{getDashboardStats().clinical.percentage}%</Text>
                                  <Text style={styles.gaugeChartLabel}>Clinical</Text>
                                </View>
                              </View>
                            </View>
                            <View style={styles.gaugeChartLegend}>
                              <View style={styles.gaugeLegendItem}>
                                <View style={[styles.gaugeLegendDot, { backgroundColor: '#93C5FD' }]} />
                                <Text style={styles.gaugeLegendText}>Clinical ({getDashboardStats().clinical.count})</Text>
                              </View>
                              <View style={styles.gaugeLegendItem}>
                                <View style={[styles.gaugeLegendDot, { backgroundColor: '#FBBF24' }]} />
                                <Text style={styles.gaugeLegendText}>Non-Clinical ({getDashboardStats().nonClinical.count})</Text>
                              </View>
                            </View>
                          </View>

                          {/* Certification Gauge */}
                          <View style={styles.gaugeChartContainer}>
                            <View style={styles.gaugeChartHeader}>
                              <Text style={styles.gaugeChartTitle}>Certification Rate</Text>
                              <MaterialCommunityIcons name="certificate" size={20} color="#34D399" />
                            </View>
                            <View style={styles.gaugeChartWrapper}>
                              <View style={styles.gaugeChart}>
                                <View style={styles.gaugeChartArc}>
                                  <View 
                                    style={[
                                      styles.gaugeChartFill, 
                                      { 
                                        transform: [{ rotate: `${(getDashboardStats().certifiedEligible.percentage * 1.8) - 90}deg` }],
                                        backgroundColor: '#34D399'
                                      }
                                    ]} 
                                  />
                                </View>
                                <View style={styles.gaugeChartCenter}>
                                  <Text style={styles.gaugeChartValue}>{getDashboardStats().certifiedEligible.percentage}%</Text>
                                  <Text style={styles.gaugeChartLabel}>Eligible</Text>
                                </View>
                              </View>
                            </View>
                            <View style={styles.gaugeChartLegend}>
                              <View style={styles.gaugeLegendItem}>
                                <View style={[styles.gaugeLegendDot, { backgroundColor: '#34D399' }]} />
                                <Text style={styles.gaugeLegendText}>Eligible ({getDashboardStats().certifiedEligible.count})</Text>
                              </View>
                              <View style={styles.gaugeLegendItem}>
                                <View style={[styles.gaugeLegendDot, { backgroundColor: '#EF4444' }]} />
                                <Text style={styles.gaugeLegendText}>Not Eligible ({getDashboardStats().certifiedNotEligible.count})</Text>
                              </View>
                            </View>
                          </View>
                        </View>
                      </View>
                    </View>
                  )}
                </View>
              </ScrollView>
            ) : activeTab === 'all' ? (
              // All Results Tab
              <ScrollView
                style={styles.scrollView}
                contentContainerStyle={styles.scrollViewContent}
                refreshControl={
                  <RefreshControl refreshing={refreshing} onRefresh={onRefresh} tintColor="#e9ddc4" />
                }
                horizontal={true}
                showsHorizontalScrollIndicator={true}
              >
                <View style={styles.tableContainer}>
                  {/* Table Header */}
                  <View style={styles.tableHeader}>
                    <Text style={[styles.headerCell, styles.cellNo]}>NO</Text>
                    <Text style={[styles.headerCell, styles.cellDate]}>DATE</Text>
                    <Text style={[styles.headerCell, styles.cellName]}>NAME</Text>
                    <Text style={[styles.headerCell, styles.cellIc]}>IC</Text>
                    <Text style={[styles.headerCell, styles.cellJawatan]}>JAWATAN</Text>
                    <Text style={[styles.headerCell, styles.cellStatus]}>ONE MAN CPR</Text>
                    <Text style={[styles.headerCell, styles.cellStatus]}>TWO MAN CPR</Text>
                    <Text style={[styles.headerCell, styles.cellStatus]}>ADULT CHOKING</Text>
                    <Text style={[styles.headerCell, styles.cellStatus]}>INFANT CHOKING</Text>
                    <Text style={[styles.headerCell, styles.cellStatus]}>INFANT CPR</Text>
                    <Text style={[styles.headerCell, styles.cellScore]}>PRETEST</Text>
                    <Text style={[styles.headerCell, styles.cellScore]}>POST TEST</Text>
                    <Text style={[styles.headerCell, styles.cellStatus]}>REMEDIAL</Text>
                    <Text style={[styles.headerCell, styles.cellStatus]}>CERTIFIED</Text>
                  </View>

                  {/* Table Rows */}
                  {getPaginatedResults().length === 0 && !loading ? (
                    <View style={styles.emptyRow}>
                      <Text style={styles.emptyText}>
                        {searchQuery || dateFilterType !== 'all'
                          ? 'No participants found matching your criteria.' 
                          : 'No participants have completed tests or BLS checklists yet.'
                        }
                      </Text>
                    </View>
                  ) : (
                    getPaginatedResults().map((result, index) => {
                      const globalIndex = ((currentPage - 1) * resultsPerPage) + index + 1;
                      return (
                      <TouchableOpacity
                        key={result.id}
                        style={styles.tableRow}
                        onPress={() => viewDetails(result)}
                        activeOpacity={0.7}
                      >
                        <Text style={[styles.cell, styles.cellNo]}>{globalIndex}</Text>
                        <Text style={[styles.cell, styles.cellDate]}>{result.date}</Text>
                        <Text style={[styles.cell, styles.cellName]}>
                          {result.participantName}
                        </Text>
                        <Text style={[styles.cell, styles.cellIc]}>
                          {result.participantId}
                        </Text>
                        <View style={[styles.cell, styles.cellJawatan]}>
                          <Text style={styles.jawatanText} numberOfLines={2}>
                            {result.jawatan || 'N/A'}
                          </Text>
                          {result.jawatan && result.jawatan.includes('N/A') && (
                            <Text style={[styles.jawatanText, { fontSize: 8, color: '#ff6b6b', fontStyle: 'italic' }]}>
                              Missing data
                            </Text>
                          )}
                        </View>
                        <View style={[styles.cell, styles.cellStatus]}>
                          {renderStatusButton(result.oneManCprPass, result, 'one-man-cpr')}
                        </View>
                        <View style={[styles.cell, styles.cellStatus]}>
                          {renderStatusButton(result.twoManCprPass, result, 'two-man-cpr')}
                        </View>
                        <View style={[styles.cell, styles.cellStatus]}>
                          {renderStatusButton(result.adultChokingPass, result, 'adult-choking')}
                        </View>
                        <View style={[styles.cell, styles.cellStatus]}>
                          {renderStatusButton(result.infantChokingPass, result, 'infant-choking')}
                        </View>
                        <View style={[styles.cell, styles.cellStatus]}>
                          {renderStatusButton(result.infantCprPass, result, 'infant-cpr')}
                        </View>
                        <TouchableOpacity 
                          style={[styles.cell, styles.cellScore]}
                          onPress={() => result.preTestScore !== null ? viewPretestDetails(result) : null}
                          disabled={result.preTestScore === null}
                        >
                          <Text style={[
                            styles.cellScoreText,
                            result.preTestScore !== null ? styles.clickableScore : styles.disabledScore,
                            { color: getScoreTextColor(result.preTestScore, result.category, 'pretest') }
                          ]}>
                            {result.preTestScore !== null ? `${result.preTestScore}/30` : "N/A"}
                          </Text>
                        </TouchableOpacity>
                        <TouchableOpacity 
                          style={[styles.cell, styles.cellScore]}
                          onPress={() => result.postTestScore !== null ? viewPosttestDetails(result) : null}
                          disabled={result.postTestScore === null}
                        >
                          <Text style={[
                            styles.cellScoreText,
                            result.postTestScore !== null ? styles.clickableScore : styles.disabledScore,
                            { color: getScoreTextColor(result.postTestScore, result.category, 'posttest') }
                          ]}>
                            {result.postTestScore !== null ? `${result.postTestScore}/30` : "N/A"}
                          </Text>
                        </TouchableOpacity>
                        <View style={[styles.cell, styles.cellStatus]}>
                          {renderRemedialStatus(result.postTestScore, result.category)}
                        </View>
                        <View style={[styles.cell, styles.cellStatus]}>
                          {renderCertifiedStatus(result)}
                        </View>
                      </TouchableOpacity>
                      );
                    })
                  )}
                </View>
              </ScrollView>
            ) : (
              // New Statistics Tabs (Pre Test or Post Test) with Modern Features
              <ScrollView
                style={styles.scrollView}
                contentContainerStyle={styles.scrollViewContent}
                refreshControl={
                  <RefreshControl refreshing={refreshing} onRefresh={onRefresh} tintColor="#e9ddc4" />
                }
              >
                <View style={styles.futuristicStatsContainer}>
                  {/* Futuristic Header */}
                  <View style={styles.futuristicStatsHeader}>
                    <View style={styles.statsHeaderGlow} />
                    <View style={styles.statsHeaderContent}>
                      <View style={styles.statsLogoContainer}>
                        <MaterialCommunityIcons 
                          name={activeTab === 'pretest' ? 'school' : 'chart-line-variant'} 
                          size={32} 
                          color="#00ffc8" 
                        />
                        <Text style={styles.futuristicStatsTitle}>
                          {activeTab === 'pretest' ? 'PRE TEST' : 'POST TEST'} ANALYTICS
                    </Text>
                      </View>
                    </View>
                    <Text style={styles.futuristicStatsSubtitle}>
                      Advanced Performance Insights & Question Analysis
                    </Text>
                  </View>

                  {getFilteredResults().length === 0 ? (
                    <View style={styles.emptyStatsContainer}>
                      <MaterialCommunityIcons name="chart-line" size={48} color="#8a7f6a" />
                      <Text style={styles.emptyStatsText}>
                        No {activeTab === 'pretest' ? 'pre test' : 'post test'} data available yet.
                      </Text>
                    </View>
                  ) : (
                    <View style={styles.futuristicStatsContent}>
                      {/* 1. Highest Scores Section */}
                      <View style={styles.highestScoresSection}>
                        <View style={styles.sectionHeader}>
                          <Text style={styles.futuristicSectionTitle}>Peak Performance Scores</Text>
                          <View style={styles.sectionGlow} />
                        </View>
                        
                        <View style={styles.scoresGrid}>
                          <TouchableOpacity 
                            style={styles.scoreCard}
                            onPress={() => showHighestScorers('clinical')}
                            activeOpacity={0.8}
                          >
                            <View style={styles.scoreCardHeader}>
                              <MaterialCommunityIcons name="medical-bag" size={24} color="#00ffc8" />
                              <Text style={styles.scoreCardTitle}>Clinical Staff</Text>
                              <MaterialCommunityIcons name="chevron-right" size={16} color="rgba(255, 255, 255, 0.5)" />
                        </View>
                            <View style={styles.scoreValues}>
                              <View style={styles.scoreItem}>
                                <Text style={styles.scoreLabel}>Highest Score</Text>
                                <Text style={styles.scoreValue}>
                                  {getNewDashboardStats().highestScores.clinical[activeTab === 'pretest' ? 'preTest' : 'postTest']}
                          </Text>
                        </View>
                      </View>
                            <Text style={styles.clickHint}>Tap to see top 3</Text>
                          </TouchableOpacity>

                          <TouchableOpacity 
                            style={styles.scoreCard}
                            onPress={() => showHighestScorers('non-clinical')}
                            activeOpacity={0.8}
                          >
                            <View style={styles.scoreCardHeader}>
                              <MaterialCommunityIcons name="account-group" size={24} color="#ff6b6b" />
                              <Text style={styles.scoreCardTitle}>Non-Clinical Staff</Text>
                              <MaterialCommunityIcons name="chevron-right" size={16} color="rgba(255, 255, 255, 0.5)" />
                            </View>
                            <View style={styles.scoreValues}>
                              <View style={styles.scoreItem}>
                                <Text style={styles.scoreLabel}>Highest Score</Text>
                                <Text style={styles.scoreValue}>
                                  {getNewDashboardStats().highestScores.nonClinical[activeTab === 'pretest' ? 'preTest' : 'postTest']}
                        </Text>
                      </View>
                            </View>
                            <Text style={styles.clickHint}>Tap to see top 3</Text>
                          </TouchableOpacity>
                            </View>
                          </View>
                          
                      {/* 2. Pass/Fail Statistics with Modern Charts */}
                      <View style={styles.passFailSection}>
                        <View style={styles.sectionHeader}>
                          <Text style={styles.futuristicSectionTitle}>Performance Distribution</Text>
                          <View style={styles.sectionGlow} />
                        </View>
                        
                        <View style={styles.chartsGrid}>
                          {/* Pass/Fail Chart */}
                          <View style={styles.modernChartCard}>
                            <View style={styles.chartHeader}>
                              <Text style={styles.chartTitle}>
                                {activeTab === 'pretest' ? 'Pre-Test' : 'Post-Test'} Results
                              </Text>
                              <View style={styles.chartBadge}>
                                <Text style={styles.chartBadgeText}>
                                  {activeTab === 'pretest' ? 'PRE' : 'POST'}
                                </Text>
                            </View>
                            </View>
                            <View style={styles.donutChartContainer}>
                              <View style={styles.donutChart}>
                                <View style={styles.donutChartInner}>
                                  <Text style={styles.donutPercentage}>
                                    {(() => {
                                      const stats = getNewDashboardStats().passFailStats[activeTab === 'pretest' ? 'preTest' : 'postTest'];
                                      const total = stats.total; // Use total participants who took the test
                                      return total > 0 ? Math.round((stats.pass / total) * 100) : 0;
                                    })()}%
                                  </Text>
                                  <Text style={styles.donutLabel}>Pass Rate</Text>
                            </View>
                                <View style={styles.donutRing}>
                              <View 
                                style={[
                                      styles.donutSegment,
                                      { 
                                        transform: [{ rotate: `${(() => {
                                          const stats = getNewDashboardStats().passFailStats[activeTab === 'pretest' ? 'preTest' : 'postTest'];
                                          const total = stats.total; // Use total participants who took the test
                                          return total > 0 ? (stats.pass / total) * 360 : 0;
                                        })()}deg` }],
                                        backgroundColor: activeTab === 'pretest' ? '#00ffc8' : '#4fc3f7',
                                        borderWidth: 3,
                                        borderColor: '#ffffff'
                                  }
                                ]} 
                              />
                            </View>
                          </View>
                            </View>
                            <View style={styles.chartLegend}>
                              <View style={styles.legendItem}>
                                <View style={[styles.legendDot, { backgroundColor: activeTab === 'pretest' ? '#00ffc8' : '#4fc3f7' }]} />
                                <Text style={styles.legendText}>
                                  Pass: {getNewDashboardStats().passFailStats[activeTab === 'pretest' ? 'preTest' : 'postTest'].pass}
                              </Text>
                            </View>
                              <View style={styles.legendItem}>
                                <View style={[styles.legendDot, { backgroundColor: '#ff6b6b' }]} />
                                <Text style={styles.legendText}>
                                  Fail: {getNewDashboardStats().passFailStats[activeTab === 'pretest' ? 'preTest' : 'postTest'].fail}
                                </Text>
                        </View>
                              <View style={styles.legendItem}>
                                <View style={[styles.legendDot, { backgroundColor: '#8a7f6a' }]} />
                                <Text style={styles.legendText}>
                                  Total: {getNewDashboardStats().passFailStats[activeTab === 'pretest' ? 'preTest' : 'postTest'].total}
                                </Text>
                        </View>
                            </View>
                          </View>
                        </View>
                      </View>

                      {/* 3. Question Analysis Section */}
                      <View style={styles.questionAnalysisSection}>
                        <View style={styles.sectionHeader}>
                          <Text style={styles.futuristicSectionTitle}>Question Performance Analysis</Text>
                          <View style={styles.sectionGlow} />
                      </View>

                        <View style={styles.questionsList}>
                          {getQuestionAnalysis().map((question, index) => (
                            <View key={question.questionId} style={styles.questionCard}>
                              <View style={styles.questionHeader}>
                                <View style={styles.questionNumber}>
                                  <Text style={styles.questionNumberText}>Q{question.questionId}</Text>
                                </View>
                                <View style={styles.questionAccuracy}>
                                  <Text style={styles.accuracyText}>{question.accuracy}%</Text>
                                  <Text style={styles.accuracyLabel}>Accuracy</Text>
                                </View>
                              </View>
                              
                              <Text style={styles.questionText} numberOfLines={3}>
                                {question.questionText}
                              </Text>
                              
                              {/* Answer Choices Distribution */}
                              <View style={styles.answerChoicesContainer}>
                                <Text style={styles.answerChoicesTitle}>Answer Distribution:</Text>
                                <View style={styles.answerChoicesList}>
                                  {Object.entries(question.answerChoices || {}).map(([choice, data]) => (
                                    <View key={choice} style={styles.answerChoiceRow}>
                                      <View style={[
                                        styles.answerChoiceBadge,
                                        { 
                                          backgroundColor: data.isCorrect ? '#28a745' : '#dc3545',
                                          borderColor: data.isCorrect ? '#28a745' : '#dc3545'
                                        }
                                      ]}>
                                        <Text style={styles.answerChoiceLetter}>{choice}</Text>
                            </View>
                                      <View style={styles.answerChoiceContent}>
                                        <Text style={styles.answerChoiceText} numberOfLines={2}>
                                          {data.text}
                                        </Text>
                                        <View style={styles.answerChoiceStats}>
                                          <Text style={styles.answerChoiceCount}>{data.count} responses</Text>
                                          <Text style={[
                                            styles.answerChoiceLabel,
                                            { color: data.isCorrect ? '#28a745' : '#dc3545' }
                                          ]}>
                                            {data.isCorrect ? 'âœ“ Correct' : 'âœ— Wrong'}
                                          </Text>
                                        </View>
                                      </View>
                          </View>
                        ))}
                      </View>
                              </View>
                              
                              <View style={styles.questionStats}>
                                <View style={styles.statItem}>
                                  <Text style={styles.statLabel}>Correct:</Text>
                                  <Text style={[styles.statValue, { color: '#28a745' }]}>{question.correctCount}</Text>
                                </View>
                                <View style={styles.statItem}>
                                  <Text style={styles.statLabel}>Incorrect:</Text>
                                  <Text style={[styles.statValue, { color: '#dc3545' }]}>{question.incorrectCount}</Text>
                                </View>
                                <View style={styles.statItem}>
                                  <Text style={styles.statLabel}>Accuracy:</Text>
                                  <Text style={[styles.statValue, { color: question.accuracy >= 70 ? '#28a745' : question.accuracy >= 50 ? '#ffc107' : '#dc3545' }]}>
                                    {question.accuracy.toFixed(1)}%
                                  </Text>
                                </View>
                              </View>
                              
                              <View style={styles.suggestionBox}>
                                <MaterialCommunityIcons name="lightbulb-outline" size={16} color="#ffd93d" />
                                <Text style={styles.suggestionText}>{question.suggestion}</Text>
                              </View>
                            </View>
                          ))}
                        </View>
                      </View>
                    </View>
                  )}
                </View>
              </ScrollView>
            )}
          </>
        )}

        {/* Simple Combined Detail Modal */}
        <Modal visible={showDetailModal} transparent animationType="slide" onRequestClose={() => setShowDetailModal(false)}>
          <View style={styles.modalBackdrop}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Complete Assessment Results</Text>
                <TouchableOpacity onPress={() => setShowDetailModal(false)} style={styles.closeButton}>
                  <MaterialCommunityIcons name="close" size={20} color="#e9ddc4" />
                </TouchableOpacity>
              </View>
              
              {selectedResult && (
                <ScrollView style={styles.modalBody}>
                  {/* Participant Info */}
                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Participant Information</Text>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Name:</Text>
                      <Text style={styles.detailValue}>{selectedResult.participantName}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>IC:</Text>
                      <Text style={styles.detailValue}>{selectedResult.participantId}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Date:</Text>
                      <Text style={styles.detailValue}>{selectedResult.date}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Jawatan:</Text>
                      <Text style={styles.detailValue}>
                        {selectedResult.jawatan || 'N/A'}
                        {selectedResult.jawatan && selectedResult.jawatan.includes('N/A') && (
                          <Text style={{ color: '#ff6b6b', fontStyle: 'italic', fontSize: 12 }}>
                            {' '}(Missing data)
                          </Text>
                        )}
                      </Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Category:</Text>
                      <Text style={[styles.detailValue, { 
                        color: selectedResult.category === 'clinical' ? '#00ffc8' : '#ffc107' 
                      }]}>
                        {selectedResult.category === 'clinical' ? 'CLINICAL' : 'NON-CLINICAL'}
                      </Text>
                    </View>
                  </View>

                  {/* Test Scores */}
                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>ðŸ“ Test Scores</Text>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Pre-Test:</Text>
                      <Text style={[styles.simpleValue, {
                        color: getScoreTextColor(selectedResult.preTestScore, selectedResult.category, 'pretest')
                      }]}>
                        {selectedResult.preTestScore !== null ? `${selectedResult.preTestScore}/30` : "N/A"}
                      </Text>
                    </View>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Post-Test:</Text>
                      <Text style={[styles.simpleValue, {
                        color: getScoreTextColor(selectedResult.postTestScore, selectedResult.category, 'posttest')
                      }]}>
                        {selectedResult.postTestScore !== null ? `${selectedResult.postTestScore}/30` : "N/A"}
                      </Text>
                    </View>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Pass Threshold:</Text>
                      <Text style={[styles.simpleValue, { color: '#00ffc8' }]}>
                        {selectedResult.category === 'clinical' ? '25/30' : '20/30'}
                      </Text>
                    </View>
                  </View>

                  {/* Checklist Results */}
                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>âœ… Practical Assessments</Text>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>One Man CPR:</Text>
                      <Text style={[styles.simpleValue, { color: selectedResult.oneManCprPass ? "#28a745" : "#dc3545" }]}>
                        {selectedResult.oneManCprPass ? "PASS" : "FAIL"}
                      </Text>
                    </View>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Two Man CPR:</Text>
                      <Text style={[styles.simpleValue, { color: selectedResult.twoManCprPass ? "#28a745" : "#dc3545" }]}>
                        {selectedResult.twoManCprPass ? "PASS" : "FAIL"}
                      </Text>
                    </View>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Adult Choking:</Text>
                      <Text style={[styles.simpleValue, { color: selectedResult.adultChokingPass ? "#28a745" : "#dc3545" }]}>
                        {selectedResult.adultChokingPass ? "PASS" : "FAIL"}
                      </Text>
                    </View>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Infant Choking:</Text>
                      <Text style={[styles.simpleValue, { color: selectedResult.infantChokingPass ? "#28a745" : "#dc3545" }]}>
                        {selectedResult.infantChokingPass ? "PASS" : "FAIL"}
                      </Text>
                    </View>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Infant CPR:</Text>
                      <Text style={[styles.simpleValue, { color: selectedResult.infantCprPass ? "#28a745" : "#dc3545" }]}>
                        {selectedResult.infantCprPass ? "PASS" : "FAIL"}
                      </Text>
                    </View>
                  </View>

                  {/* Final Status */}
                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Final Status</Text>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Remedial Allowed:</Text>
                      <Text style={[styles.simpleValue, { 
                        color: calculateRemedialAllowed(selectedResult.postTestScore, selectedResult.category) ? "#00FFFF" : "#DC143C" 
                      }]}>
                        {calculateRemedialAllowed(selectedResult.postTestScore, selectedResult.category) ? "ALLOW" : "NOT ALLOW"}
                      </Text>
                    </View>
                    <View style={styles.simpleRow}>
                      <Text style={styles.simpleLabel}>Certified:</Text>
                      <Text style={[styles.simpleValue, { 
                        color: calculateCertified(selectedResult) ? "#28a745" : "#dc3545" 
                      }]}>
                        {calculateCertified(selectedResult) ? "YES" : "NO"}
                      </Text>
                    </View>
                  </View>
                </ScrollView>
              )}
            </View>
          </View>
        </Modal>

        {/* Checklist Detail Modal */}
        <Modal visible={showChecklistModal} transparent animationType="slide" onRequestClose={() => setShowChecklistModal(false)}>
          <View style={styles.modalBackdrop}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>
                  {selectedChecklist ? getChecklistDisplayName(selectedChecklist.checklistType) : ''} Checklist Details
                </Text>
                <TouchableOpacity onPress={() => setShowChecklistModal(false)} style={styles.closeButton}>
                  <MaterialCommunityIcons name="close" size={20} color="#e9ddc4" />
                </TouchableOpacity>
              </View>
              
              {selectedChecklist && (
                <ScrollView style={styles.modalBody}>
                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Assessment Information</Text>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Participant Name:</Text>
                      <Text style={styles.detailValue}>{selectedChecklist.participantName}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Participant ID:</Text>
                      <Text style={styles.detailValue}>{selectedChecklist.participantId}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Checklist Type:</Text>
                      <Text style={styles.detailValue}>{getChecklistDisplayName(selectedChecklist.checklistType)}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Examiner:</Text>
                      <Text style={styles.detailValue}>
                        {selectedChecklist.examinerName} ({selectedChecklist.examinerIc})
                      </Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Assessment Date:</Text>
                      <Text style={styles.detailValue}>
                        {new Date(selectedChecklist.assessmentDate).toLocaleDateString()}
                      </Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Score:</Text>
                      <Text style={styles.detailValue}>
                        {selectedChecklist.score}/{selectedChecklist.totalItems} ({selectedChecklist.status})
                      </Text>
                    </View>
                  </View>

                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Checklist Details</Text>
                    {renderChecklistDetails(selectedChecklist.checklistType, selectedChecklist.details)}
                  </View>

                  {selectedChecklist.comments && selectedChecklist.comments.trim() && (
                    <View style={styles.detailSection}>
                      <Text style={styles.detailSectionTitle}>Examiner Comments</Text>
                      <View style={styles.commentsContainer}>
                        <Text style={styles.commentsText}>{selectedChecklist.comments}</Text>
                      </View>
                    </View>
                  )}

                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Summary</Text>
                    {(() => {
                      const details = selectedChecklist.details;
                      let totalSteps, performedCount, notPerformedCount;
                      
                      // Handle new structure: {danger_ppe: true, response_shoulder_tap: false, ...}
                      if (details.danger_ppe !== undefined || details.performed === undefined) {
                        totalSteps = Object.keys(details).length;
                        performedCount = Object.values(details).filter(v => v === true).length;
                        notPerformedCount = Object.values(details).filter(v => v === false).length;
                      } else {
                        // Handle old structure: {performed: [...], notPerformed: [...]}
                        const performedItems = details.performed || [];
                        const notPerformedItems = details.notPerformed || [];
                        totalSteps = performedItems.length + notPerformedItems.length;
                        performedCount = performedItems.length;
                        notPerformedCount = notPerformedItems.length;
                      }
                      
                      return (
                        <>
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Total Steps:</Text>
                            <Text style={styles.summaryValue}>{totalSteps}</Text>
                    </View>
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Performed:</Text>
                      <Text style={[styles.summaryValue, { color: "#28a745" }]}>
                              {performedCount}
                      </Text>
                    </View>
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Not Performed:</Text>
                      <Text style={[styles.summaryValue, { color: "#dc3545" }]}>
                              {notPerformedCount}
                      </Text>
                    </View>
                        </>
                      );
                    })()}
                    {(() => {
                      const details = selectedChecklist.details;
                      let completionRate;
                      
                      // Handle new structure: {danger_ppe: true, response_shoulder_tap: false, ...}
                      if (details.danger_ppe !== undefined || details.performed === undefined) {
                        const total = Object.keys(details).length;
                        const performed = Object.values(details).filter(v => v === true).length;
                        completionRate = total > 0 ? Math.round((performed / total) * 100) : 0;
                      } else {
                        // Handle old structure: {performed: [...], notPerformed: [...]}
                        const performedItems = details.performed || [];
                        const notPerformedItems = details.notPerformed || [];
                        const total = performedItems.length + notPerformedItems.length;
                        completionRate = total > 0 ? Math.round((performedItems.length / total) * 100) : 0;
                      }
                      
                      return (
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Completion Rate:</Text>
                      <Text style={[styles.summaryValue, { color: "#00ffc8" }]}>
                            {completionRate}%
                      </Text>
                    </View>
                      );
                    })()}
                  </View>
                </ScrollView>
              )}
            </View>
          </View>
        </Modal>

        {/* Date Filter Modal */}
        <Modal visible={showDatePicker} transparent animationType="slide" onRequestClose={() => setShowDatePicker(false)}>
          <View style={styles.modalBackdrop}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Filter by Date</Text>
                <TouchableOpacity onPress={() => setShowDatePicker(false)} style={styles.closeButton}>
                  <MaterialCommunityIcons name="close" size={20} color="#e9ddc4" />
                </TouchableOpacity>
              </View>
              
              <View style={styles.dateFilterContainer}>
                {/* Filter Type Options */}
                <View style={styles.filterTypeContainer}>
                  <Text style={styles.filterTypeTitle}>Select Time Period:</Text>
                  
                  <TouchableOpacity
                    style={[styles.filterTypeButton, dateFilterType === 'all' && styles.filterTypeButtonActive]}
                    onPress={() => {
                      setDateFilterType('all');
                      setDateFilter('');
                    }}
                  >
                    <MaterialCommunityIcons 
                      name="clock-outline" 
                      size={20} 
                      color={dateFilterType === 'all' ? '#1a1a2e' : '#00ffc8'} 
                    />
                    <Text style={[styles.filterTypeText, dateFilterType === 'all' && styles.filterTypeTextActive]}>
                      All Time
                    </Text>
                  </TouchableOpacity>
                  
                  <TouchableOpacity
                    style={[styles.filterTypeButton, dateFilterType === 'today' && styles.filterTypeButtonActive]}
                    onPress={() => {
                      setDateFilterType('today');
                      setDateFilter('');
                    }}
                  >
                    <MaterialCommunityIcons 
                      name="calendar-today" 
                      size={20} 
                      color={dateFilterType === 'today' ? '#1a1a2e' : '#00ffc8'} 
                    />
                    <Text style={[styles.filterTypeText, dateFilterType === 'today' && styles.filterTypeTextActive]}>
                      Today
                    </Text>
                  </TouchableOpacity>
                  
                  <TouchableOpacity
                    style={[styles.filterTypeButton, dateFilterType === '7days' && styles.filterTypeButtonActive]}
                    onPress={() => {
                      setDateFilterType('7days');
                      setDateFilter('');
                    }}
                  >
                    <MaterialCommunityIcons 
                      name="calendar-week" 
                      size={20} 
                      color={dateFilterType === '7days' ? '#1a1a2e' : '#00ffc8'} 
                    />
                    <Text style={[styles.filterTypeText, dateFilterType === '7days' && styles.filterTypeTextActive]}>
                      Last 7 Days
                    </Text>
                  </TouchableOpacity>
                  
                  <TouchableOpacity
                    style={[styles.filterTypeButton, dateFilterType === 'custom' && styles.filterTypeButtonActive]}
                    onPress={() => {
                      setDateFilterType('custom');
                    }}
                  >
                    <MaterialCommunityIcons 
                      name="calendar-edit" 
                      size={20} 
                      color={dateFilterType === 'custom' ? '#1a1a2e' : '#00ffc8'} 
                    />
                    <Text style={[styles.filterTypeText, dateFilterType === 'custom' && styles.filterTypeTextActive]}>
                      Custom Date
                    </Text>
                  </TouchableOpacity>
                </View>
                
                {/* Custom Date Picker */}
                {dateFilterType === 'custom' && (
                  <View style={styles.customDateContainer}>
                    <Text style={styles.customDateTitle}>Select Custom Date:</Text>
                {renderDatePicker()}
                  </View>
                )}
                
                <View style={styles.datePickerButtons}>
                  <TouchableOpacity
                    style={styles.datePickerButton}
                    onPress={() => {
                      setDateFilterType('all');
                      setDateFilter('');
                      setShowDatePicker(false);
                    }}
                  >
                    <Text style={styles.datePickerButtonText}>Clear Filter</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.datePickerButton, styles.datePickerButtonPrimary]}
                    onPress={() => {
                      if (dateFilterType === 'custom') {
                      const selectedDateStr = selectedDate.toISOString().split('T')[0];
                      setDateFilter(selectedDateStr);
                      }
                      setShowDatePicker(false);
                    }}
                  >
                    <Text style={[styles.datePickerButtonText, styles.datePickerButtonTextPrimary]}>Apply</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </View>
        </Modal>

        {/* Pretest Details Modal */}
        <Modal visible={showPretestModal} transparent animationType="slide" onRequestClose={() => setShowPretestModal(false)}>
          <View style={styles.modalBackdrop}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Pretest Details</Text>
                <TouchableOpacity onPress={() => setShowPretestModal(false)} style={styles.closeButton}>
                  <MaterialCommunityIcons name="close" size={20} color="#e9ddc4" />
                </TouchableOpacity>
              </View>
              
              {selectedPretest && (
                <ScrollView style={styles.modalBody}>
                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Assessment Information</Text>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Name:</Text>
                      <Text style={styles.detailValue}>{selectedPretest.participantName}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>IC:</Text>
                      <Text style={styles.detailValue}>{selectedPretest.participantId}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Category:</Text>
                      <Text style={[styles.detailValue, { 
                        color: selectedPretest.category === 'clinical' ? '#00ffc8' : '#ffc107' 
                      }]}>
                        {selectedPretest.category === 'clinical' ? 'CLINICAL' : 'NON-CLINICAL'}
                      </Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Score:</Text>
                      <Text style={[styles.detailValue, {
                        color: getScoreTextColor(selectedPretest.score, selectedPretest.category, 'pretest')
                      }]}>
                        {selectedPretest.score}/{selectedPretest.totalQuestions} 
                        ({Math.round((selectedPretest.score / selectedPretest.totalQuestions) * 100)}%)
                      </Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Pass Threshold:</Text>
                      <Text style={[styles.detailValue, { color: '#00ffc8' }]}>
                        {selectedPretest.category === 'clinical' ? '25/30' : '20/30'}
                      </Text>
                    </View>
                  </View>

                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Questions and Answers</Text>
                    {pretestQuestions.map((question, index) => (
                      <View key={question.id} style={styles.questionContainer}>
                        <View style={styles.questionHeader}>
                          <Text style={styles.questionNumber}>Question {index + 1}</Text>
                          <View style={[
                            styles.answerStatus,
                            { backgroundColor: question.isCorrect ? '#28a745' : '#dc3545' }
                          ]}>
                            <Text style={styles.answerStatusText}>
                              {question.isCorrect ? 'CORRECT' : 'INCORRECT'}
                            </Text>
                          </View>
                        </View>
                        
                        <Text style={styles.questionText}>{question.text}</Text>
                        
                        <View style={styles.choicesContainer}>
                          {question.choices.map((choice, choiceIndex) => {
                            const letter = String.fromCharCode(65 + choiceIndex); // A, B, C, D
                            const isUserAnswer = question.userAnswer === letter;
                            const isCorrectAnswer = question.correctAnswer === letter;
                            
                            return (
                              <View key={choiceIndex} style={[
                                styles.choiceContainer,
                                isUserAnswer && styles.userAnswerChoice,
                                isCorrectAnswer && styles.correctAnswerChoice
                              ]}>
                                <Text style={[
                                  styles.choiceLetter,
                                  isUserAnswer && styles.userAnswerText,
                                  isCorrectAnswer && styles.correctAnswerText
                                ]}>
                                  {letter}.
                                </Text>
                                <Text style={[
                                  styles.choiceText,
                                  isUserAnswer && styles.userAnswerText,
                                  isCorrectAnswer && styles.correctAnswerText
                                ]}>
                                  {choice}
                                </Text>
                                {isUserAnswer && (
                                  <MaterialCommunityIcons 
                                    name={question.isCorrect ? "check-circle" : "close-circle"} 
                                    size={16} 
                                    color={question.isCorrect ? "#28a745" : "#dc3545"} 
                                    style={styles.choiceIcon}
                                  />
                                )}
                                {isCorrectAnswer && !isUserAnswer && (
                                  <MaterialCommunityIcons 
                                    name="check-circle" 
                                    size={16} 
                                    color="#28a745" 
                                    style={styles.choiceIcon}
                                  />
                                )}
                              </View>
                            );
                          })}
                        </View>
                        
                        <View style={styles.answerSummary}>
                          <Text style={styles.answerSummaryText}>
                            Your Answer: {question.userAnswer || 'Not answered'}
                          </Text>
                          <Text style={styles.answerSummaryText}>
                            Correct Answer: {question.correctAnswer}
                          </Text>
                        </View>
                      </View>
                    ))}
                  </View>
                </ScrollView>
              )}
            </View>
          </View>
        </Modal>

        {/* Posttest Details Modal */}
        <Modal visible={showPosttestModal} transparent animationType="slide" onRequestClose={() => setShowPosttestModal(false)}>
          <View style={styles.modalBackdrop}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Posttest Details</Text>
                <TouchableOpacity onPress={() => setShowPosttestModal(false)} style={styles.closeButton}>
                  <MaterialCommunityIcons name="close" size={20} color="#e9ddc4" />
                </TouchableOpacity>
              </View>
              
              {selectedPosttest && (
                <ScrollView style={styles.modalBody}>
                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Assessment Information</Text>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Name:</Text>
                      <Text style={styles.detailValue}>{selectedPosttest.participantName}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>IC:</Text>
                      <Text style={styles.detailValue}>{selectedPosttest.participantId}</Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Category:</Text>
                      <Text style={[styles.detailValue, { 
                        color: selectedPosttest.category === 'clinical' ? '#00ffc8' : '#ffc107' 
                      }]}>
                        {selectedPosttest.category === 'clinical' ? 'CLINICAL' : 'NON-CLINICAL'}
                      </Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Score:</Text>
                      <Text style={[styles.detailValue, {
                        color: getScoreTextColor(selectedPosttest.score, selectedPosttest.category, 'posttest')
                      }]}>
                        {selectedPosttest.score}/{selectedPosttest.totalQuestions} 
                        ({Math.round((selectedPosttest.score / selectedPosttest.totalQuestions) * 100)}%)
                      </Text>
                    </View>
                    <View style={styles.detailRow}>
                      <Text style={styles.detailLabel}>Pass Threshold:</Text>
                      <Text style={[styles.detailValue, { color: '#00ffc8' }]}>
                        {selectedPosttest.category === 'clinical' ? '25/30' : '20/30'}
                      </Text>
                    </View>
                  </View>

                  <View style={styles.detailSection}>
                    <Text style={styles.detailSectionTitle}>Questions and Answers</Text>
                    {posttestQuestions.map((question, index) => (
                      <View key={question.id} style={styles.questionContainer}>
                        <View style={styles.questionHeader}>
                          <Text style={styles.questionNumber}>Question {index + 1}</Text>
                          <View style={[
                            styles.answerStatus,
                            { backgroundColor: question.isCorrect ? '#28a745' : '#dc3545' }
                          ]}>
                            <Text style={styles.answerStatusText}>
                              {question.isCorrect ? 'CORRECT' : 'INCORRECT'}
                            </Text>
                          </View>
                        </View>
                        
                        <Text style={styles.questionText}>{question.text}</Text>
                        
                        <View style={styles.choicesContainer}>
                          {question.choices.map((choice, choiceIndex) => {
                            const letter = String.fromCharCode(65 + choiceIndex); // A, B, C, D
                            const isUserAnswer = question.userAnswer === letter;
                            const isCorrectAnswer = question.correctAnswer === letter;
                            
                            return (
                              <View key={choiceIndex} style={[
                                styles.choiceContainer,
                                isUserAnswer && styles.userAnswerChoice,
                                isCorrectAnswer && styles.correctAnswerChoice
                              ]}>
                                <Text style={[
                                  styles.choiceLetter,
                                  isUserAnswer && styles.userAnswerText,
                                  isCorrectAnswer && styles.correctAnswerText
                                ]}>
                                  {letter}.
                                </Text>
                                <Text style={[
                                  styles.choiceText,
                                  isUserAnswer && styles.userAnswerText,
                                  isCorrectAnswer && styles.correctAnswerText
                                ]}>
                                  {choice}
                                </Text>
                                {isUserAnswer && (
                                  <MaterialCommunityIcons 
                                    name={question.isCorrect ? "check-circle" : "close-circle"} 
                                    size={16} 
                                    color={question.isCorrect ? "#28a745" : "#dc3545"} 
                                    style={styles.choiceIcon}
                                  />
                                )}
                                {isCorrectAnswer && !isUserAnswer && (
                                  <MaterialCommunityIcons 
                                    name="check-circle" 
                                    size={16} 
                                    color="#28a745" 
                                    style={styles.choiceIcon}
                                  />
                                )}
                              </View>
                            );
                          })}
                        </View>
                        
                        <View style={styles.answerSummary}>
                          <Text style={styles.answerSummaryText}>
                            Your Answer: {question.userAnswer || 'Not answered'}
                          </Text>
                          <Text style={styles.answerSummaryText}>
                            Correct Answer: {question.correctAnswer}
                          </Text>
                        </View>
                      </View>
                    ))}
                  </View>
                </ScrollView>
              )}
            </View>
          </View>
        </Modal>

        {/* Participant Detail Modal */}
        <Modal
          visible={participantModalVisible}
          animationType="slide"
          transparent={true}
          onRequestClose={() => setParticipantModalVisible(false)}
        >
          <View style={styles.participantModalBackdrop}>
            <View style={styles.participantModalContent}>
              <View style={styles.participantModalHeader}>
                <Text style={styles.participantModalTitle}>
                  {selectedCategory} ({filteredParticipants.length})
                </Text>
                <TouchableOpacity
                  style={styles.participantModalCloseButton}
                  onPress={() => setParticipantModalVisible(false)}
                >
                  <MaterialCommunityIcons name="close" size={24} color="#FFFFFF" />
                </TouchableOpacity>
              </View>
              
              <ScrollView style={styles.participantModalBody}>
                {filteredParticipants.length === 0 ? (
                  <View style={styles.participantEmptyState}>
                    <MaterialCommunityIcons name="account-off" size={48} color="rgba(255, 255, 255, 0.5)" />
                    <Text style={styles.participantEmptyText}>No participants found</Text>
                  </View>
                ) : (
                  filteredParticipants.map((participant, index) => (
                    <TouchableOpacity
                      key={`${participant.participantId}-${index}`}
                      style={styles.participantItem}
                      onPress={() => {
                        setParticipantModalVisible(false);
                        viewDetails(participant);
                      }}
                    >
                      <View style={styles.participantItemHeader}>
                        <View style={styles.participantItemInfo}>
                          <Text style={styles.participantItemName}>{participant.participantName}</Text>
                          <Text style={styles.participantItemId}>{participant.participantId}</Text>
                        </View>
                        <View style={styles.participantItemStats}>
                          <View style={styles.participantStatItem}>
                            <Text style={styles.participantStatLabel}>Pre-Test</Text>
                            <Text style={[
                              styles.participantStatValue,
                              { color: getScoreTextColor(participant.preTestScore, participant.category, 'pretest') }
                            ]}>
                              {participant.preTestScore !== null ? participant.preTestScore : 'N/A'}
                            </Text>
                          </View>
                          <View style={styles.participantStatItem}>
                            <Text style={styles.participantStatLabel}>Post-Test</Text>
                            <Text style={[
                              styles.participantStatValue,
                              { color: getScoreTextColor(participant.postTestScore, participant.category, 'posttest') }
                            ]}>
                              {participant.postTestScore !== null ? participant.postTestScore : 'N/A'}
                            </Text>
                          </View>
                          <View style={styles.participantStatItem}>
                            <Text style={styles.participantStatLabel}>Category</Text>
                            <Text style={styles.participantStatValue}>{participant.category}</Text>
                          </View>
                        </View>
                      </View>
                      <View style={styles.participantItemFooter}>
                        <Text style={styles.participantItemDate}>{participant.date}</Text>
                        <View style={styles.participantItemStatus}>
                          {calculateCertified(participant) === true && (
                            <View style={styles.participantStatusBadge}>
                              <MaterialCommunityIcons name="certificate" size={12} color="#10B981" />
                              <Text style={styles.participantStatusText}>Certified</Text>
                            </View>
                          )}
                          {calculateRemedialAllowed(participant.postTestScore, participant.category) && (
                            <View style={styles.participantStatusBadge}>
                              <MaterialCommunityIcons name="school" size={12} color="#3B82F6" />
                              <Text style={styles.participantStatusText}>Remedial</Text>
                            </View>
                          )}
                        </View>
                      </View>
                    </TouchableOpacity>
                  ))
                )}
              </ScrollView>
            </View>
          </View>
        </Modal>

        {/* Date Filter Modal */}
        <Modal
          visible={showDatePicker}
          animationType="slide"
          transparent={true}
          onRequestClose={() => setShowDatePicker(false)}
        >
          <View style={styles.modalBackdrop}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Filter by Date</Text>
                <TouchableOpacity
                  style={styles.modalCloseButton}
                  onPress={() => setShowDatePicker(false)}
                >
                  <MaterialCommunityIcons name="close" size={24} color="#FFFFFF" />
                </TouchableOpacity>
              </View>
              
              <View style={styles.dateFilterOptions}>
                <TouchableOpacity
                  style={[styles.dateFilterOption, dateFilterType === 'all' && styles.dateFilterOptionActive]}
                  onPress={() => {
                    setDateFilterType('all');
                    setShowDatePicker(false);
                  }}
                >
                  <MaterialCommunityIcons name="calendar-multiple" size={20} color="#00ffc8" />
                  <Text style={styles.dateFilterOptionText}>All Time</Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[styles.dateFilterOption, dateFilterType === 'today' && styles.dateFilterOptionActive]}
                  onPress={() => {
                    setDateFilterType('today');
                    setShowDatePicker(false);
                  }}
                >
                  <MaterialCommunityIcons name="calendar-today" size={20} color="#00ffc8" />
                  <Text style={styles.dateFilterOptionText}>Today</Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[styles.dateFilterOption, dateFilterType === '7days' && styles.dateFilterOptionActive]}
                  onPress={() => {
                    setDateFilterType('7days');
                    setShowDatePicker(false);
                  }}
                >
                  <MaterialCommunityIcons name="calendar-week" size={20} color="#00ffc8" />
                  <Text style={styles.dateFilterOptionText}>Last 7 Days</Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[styles.dateFilterOption, dateFilterType === '30days' && styles.dateFilterOptionActive]}
                  onPress={() => {
                    setDateFilterType('30days');
                    setShowDatePicker(false);
                  }}
                >
                  <MaterialCommunityIcons name="calendar-range" size={20} color="#00ffc8" />
                  <Text style={styles.dateFilterOptionText}>Last 30 Days</Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[styles.dateFilterOption, dateFilterType === 'custom' && styles.dateFilterOptionActive]}
                  onPress={() => {
                    setDateFilterType('custom');
                    setShowDatePicker(false);
                  }}
                >
                  <MaterialCommunityIcons name="calendar-edit" size={20} color="#00ffc8" />
                  <Text style={styles.dateFilterOptionText}>Custom Date</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </Modal>

        {/* Highest Scorers Modal */}
        <Modal 
          visible={showHighestScorersModal} 
          transparent 
          animationType="slide" 
          onRequestClose={() => setShowHighestScorersModal(false)}
        >
          <View style={styles.modalBackdrop}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>{highestScorersData.title}</Text>
                <TouchableOpacity 
                  onPress={() => setShowHighestScorersModal(false)} 
                  style={styles.closeButton}
                >
                  <MaterialCommunityIcons name="close" size={20} color="#e9ddc4" />
                </TouchableOpacity>
              </View>
              
              <ScrollView style={styles.modalBody}>
                <Text style={styles.highestScoreText}>{highestScorersData.message}</Text>
                
                <View style={styles.scorersList}>
                  {highestScorersData.scorers.map((scorer, index) => (
                    <View key={index} style={[
                      styles.scorerItem,
                      index === 0 && styles.firstPlace,
                      index === 1 && styles.secondPlace,
                      index === 2 && styles.thirdPlace
                    ]}>
                      <View style={[
                        styles.scorerRank,
                        index === 0 && styles.firstPlaceRank,
                        index === 1 && styles.secondPlaceRank,
                        index === 2 && styles.thirdPlaceRank
                      ]}>
                        <Text style={[
                          styles.scorerRankText,
                          index === 0 && styles.firstPlaceRankText,
                          index === 1 && styles.secondPlaceRankText,
                          index === 2 && styles.thirdPlaceRankText
                        ]}>
                          {index === 0 ? 'ðŸ¥‡' : index === 1 ? 'ðŸ¥ˆ' : 'ðŸ¥‰'}
                        </Text>
                      </View>
                      <View style={styles.scorerDetails}>
                        <Text style={[
                          styles.scorerName,
                          index === 0 && styles.firstPlaceName
                        ]}>
                          {scorer.name}
                        </Text>
                        <Text style={styles.scorerPosition}>{scorer.jawatan || 'N/A'}</Text>
                        <Text style={styles.scorerDate}>{scorer.date}</Text>
                      </View>
                      <View style={[
                        styles.scorerScore,
                        index === 0 && styles.firstPlaceScore,
                        index === 1 && styles.secondPlaceScore,
                        index === 2 && styles.thirdPlaceScore
                      ]}>
                        <Text style={[
                          styles.scorerScoreText,
                          index === 0 && styles.firstPlaceScoreText,
                          index === 1 && styles.secondPlaceScoreText,
                          index === 2 && styles.thirdPlaceScoreText
                        ]}>
                          {scorer.score}/30
                        </Text>
                      </View>
                    </View>
                  ))}
                </View>
              </ScrollView>
              
              <View style={styles.modalFooter}>
                <TouchableOpacity
                  style={styles.modalButton}
                  onPress={() => setShowHighestScorersModal(false)}
                >
                  <Text style={styles.modalButtonText}>Close</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </Modal>

      </View>
    </LuxuryShell>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 10,
  },
  summaryHeader: {
    backgroundColor: 'rgba(0, 255, 200, 0.1)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.3)',
  },
  summaryText: {
    color: '#00ffc8',
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  paginationInfo: {
    color: '#8a7f6a',
    fontSize: 12,
    textAlign: 'center',
    marginTop: 4,
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
  },
  loadingText: {
    color: '#e9ddc4',
    marginLeft: 12,
    fontSize: 16,
  },
  errorContainer: {
    alignItems: 'center',
    paddingVertical: 40,
  },
  errorText: {
    color: '#ff4757',
    fontSize: 16,
    textAlign: 'center',
    marginVertical: 12,
  },
  retryButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    backgroundColor: 'rgba(0, 255, 200, 0.2)',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.4)',
  },
  retryButtonText: {
    color: '#00ffc8',
    fontSize: 14,
    fontWeight: '600',
  },
  warningContainer: {
    backgroundColor: 'rgba(255, 193, 7, 0.1)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: 'rgba(255, 193, 7, 0.3)',
  },
  warningText: {
    color: '#ffc107',
    fontSize: 14,
    textAlign: 'center',
    lineHeight: 20,
  },
  scrollView: {
    flex: 1,
  },
  scrollViewContent: {
    paddingBottom: 20,
  },
  tableContainer: {
    minWidth: 1200, // Ensure table is wide enough (adjusted for name, IC, and jawatan columns)
  },
  tableHeader: {
    flexDirection: 'row',
    backgroundColor: '#1a1a2e',
    paddingVertical: 12,
    borderBottomWidth: 2,
    borderBottomColor: '#3a3a5e',
  },
  tableRow: {
    flexDirection: 'row',
    backgroundColor: '#0f0f1f',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#2a2a4e',
    alignItems: 'center',
    minHeight: 50,
  },
  emptyRow: {
    paddingVertical: 40,
    alignItems: 'center',
  },
  emptyText: {
    color: '#8a7f6a',
    fontSize: 16,
    textAlign: 'center',
  },
  headerCell: {
    color: '#e9ddc4',
    fontWeight: 'bold',
    textAlign: 'center',
    paddingHorizontal: 4,
    fontSize: 12,
  },
  cell: {
    color: '#e9ddc4',
    textAlign: 'center',
    paddingHorizontal: 4,
    fontSize: 11,
  },
  cellNo: {
    width: 40,
  },
  cellDate: {
    width: 80,
  },
  cellName: {
    width: 180,
    textAlign: 'left',
    paddingLeft: 8,
  },
  cellIc: {
    width: 120,
    textAlign: 'center',
    fontSize: 10,
  },
  cellJawatan: {
    width: 150,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cellStatus: {
    width: 100,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cellScore: {
    width: 80,
  },
  jawatanText: {
    fontSize: 9,
    textAlign: 'center',
    color: '#e9ddc4',
    lineHeight: 12,
  },
  statusButton: {
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 4,
    minWidth: 50,
    alignItems: 'center',
  },
  statusText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  remedialText: {
    fontSize: 10,
    fontWeight: 'bold',
  },
  // Modal Styles
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.8)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    backgroundColor: '#1a1a2e',
    borderRadius: 16,
    padding: 20,
    width: '100%',
    maxWidth: 400,
    maxHeight: '80%',
    borderWidth: 1,
    borderColor: '#a8b8d8',
    alignSelf: 'center',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(100, 200, 255, 0.2)',
  },
  modalTitle: {
    color: '#a8b8d8',
    fontSize: 20,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(168, 184, 216, 0.1)',
  },
  modalBody: {
    maxHeight: '80%',
  },
  detailSection: {
    marginBottom: 24,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    padding: 16,
  },
  detailSectionTitle: {
    color: '#e9ddc4',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  detailRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  detailLabel: {
    color: '#8a7f6a',
    fontSize: 14,
    fontWeight: '600',
  },
  detailValue: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: 'bold',
  },
  scoreDetailRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingVertical: 4,
  },
  scoreDetailLabel: {
    color: '#8a7f6a',
    fontSize: 14,
    fontWeight: '600',
  },
  scoreDetailValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#e9ddc4',
  },
  checklistDetailItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: 'rgba(100, 200, 255, 0.1)',
  },
  checklistDetailProcedure: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: 'bold',
    flex: 1,
  },
  checklistDetailScore: {
    color: '#00ffc8',
    fontSize: 14,
    fontWeight: '600',
  },
  // Checklist Detail Modal Styles
  checklistStepItem: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 8,
    paddingHorizontal: 8,
  },
  checklistStepText: {
    color: '#e9ddc4',
    fontSize: 13,
    marginLeft: 8,
    flex: 1,
    lineHeight: 18,
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
    paddingVertical: 2,
  },
  summaryLabel: {
    color: '#8a7f6a',
    fontSize: 14,
    fontWeight: '600',
  },
  summaryValue: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: 'bold',
  },
  // Checklist Section Styles
  checklistSection: {
    marginBottom: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: 'rgba(100, 200, 255, 0.1)',
  },
  checklistSectionTitle: {
    color: '#00ffc8',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 255, 200, 0.3)',
    paddingBottom: 6,
  },
  // Comments Styles
  commentsContainer: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: 'rgba(100, 200, 255, 0.2)',
  },
  commentsText: {
    color: '#e9ddc4',
    fontSize: 14,
    lineHeight: 20,
    fontStyle: 'italic',
  },
  // Pretest Modal Styles
  clickableScore: {
    color: '#00ffc8',
    textDecorationLine: 'underline',
  },
  disabledScore: {
    color: '#8a7f6a',
  },
  cellScoreText: {
    color: '#e9ddc4',
    textAlign: 'center',
    paddingHorizontal: 4,
    fontSize: 11,
  },
  // Question Container Styles
  questionContainer: {
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(100, 200, 255, 0.2)',
  },
  questionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  questionNumber: {
    color: '#00ffc8',
    fontSize: 16,
    fontWeight: 'bold',
  },
  answerStatus: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 16,
  },
  answerStatusText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  questionText: {
    color: '#e9ddc4',
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 16,
  },
  choicesContainer: {
    marginBottom: 12,
  },
  choiceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    marginBottom: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    borderWidth: 1,
    borderColor: 'rgba(100, 200, 255, 0.1)',
  },
  userAnswerChoice: {
    backgroundColor: 'rgba(255, 193, 7, 0.2)',
    borderColor: '#ffc107',
  },
  correctAnswerChoice: {
    backgroundColor: 'rgba(40, 167, 69, 0.2)',
    borderColor: '#28a745',
  },
  choiceLetter: {
    color: '#8a7f6a',
    fontSize: 14,
    fontWeight: 'bold',
    marginRight: 8,
    minWidth: 20,
  },
  choiceText: {
    color: '#e9ddc4',
    fontSize: 13,
    flex: 1,
    lineHeight: 18,
  },
  userAnswerText: {
    color: '#ffc107',
    fontWeight: 'bold',
  },
  correctAnswerText: {
    color: '#28a745',
    fontWeight: 'bold',
  },
  choiceIcon: {
    marginLeft: 8,
  },
  answerSummary: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: 'rgba(100, 200, 255, 0.1)',
  },
  answerSummaryText: {
    color: '#8a7f6a',
    fontSize: 12,
    fontWeight: '600',
  },
  // Tab Navigation Styles
  tabContainer: {
    flexDirection: 'row',
    backgroundColor: '#1a1a2e',
    borderRadius: 8,
    marginBottom: 16,
    padding: 4,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 6,
    alignItems: 'center',
  },
  activeTab: {
    backgroundColor: '#00ffc8',
  },
  tabText: {
    color: '#8a7f6a',
    fontSize: 12,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  activeTabText: {
    color: '#1a1a2e',
  },
  // Search and Filter Controls
  controlsContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    gap: 12,
  },
  searchContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1a1a2e',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    color: '#e9ddc4',
    fontSize: 14,
  },
  clearButton: {
    marginLeft: 8,
    padding: 4,
  },
  dateFilterButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1a1a2e',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: '#00ffc8',
  },
  dateFilterText: {
    color: '#00ffc8',
    fontSize: 12,
    fontWeight: '600',
    marginLeft: 6,
    flex: 1,
  },
  dropdownIcon: {
    marginLeft: 8,
  },
  exportButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1a1a2e',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: '#00ffc8',
  },
  exportButtonText: {
    color: '#00ffc8',
    fontSize: 12,
    fontWeight: '600',
    marginLeft: 6,
  },
  // Pagination Styles
  paginationControls: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'rgba(26, 26, 46, 0.8)',
    borderRadius: 6,
    paddingHorizontal: 12,
    paddingVertical: 8,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: 'rgba(58, 58, 94, 0.5)',
  },
  resultsPerPageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  resultsPerPageLabel: {
    color: '#8a7f6a',
    fontSize: 11,
    fontWeight: '500',
    marginRight: 6,
  },
  resultsPerPageButtons: {
    flexDirection: 'row',
    gap: 2,
  },
  resultsPerPageButton: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    backgroundColor: 'rgba(42, 42, 62, 0.6)',
    borderWidth: 1,
    borderColor: 'rgba(58, 58, 94, 0.3)',
    minWidth: 28,
    alignItems: 'center',
  },
  resultsPerPageButtonActive: {
    backgroundColor: '#00ffc8',
    borderColor: '#00ffc8',
  },
  resultsPerPageButtonText: {
    color: '#8a7f6a',
    fontSize: 10,
    fontWeight: '600',
  },
  resultsPerPageButtonTextActive: {
    color: '#1a1a2e',
  },
  pageNavigation: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  pageButton: {
    padding: 6,
    borderRadius: 4,
    backgroundColor: 'rgba(42, 42, 62, 0.6)',
    borderWidth: 1,
    borderColor: 'rgba(58, 58, 94, 0.3)',
    minWidth: 28,
    alignItems: 'center',
    justifyContent: 'center',
  },
  pageButtonDisabled: {
    backgroundColor: 'rgba(26, 26, 46, 0.3)',
    borderColor: 'rgba(42, 42, 62, 0.3)',
  },
  pageInfo: {
    color: '#8a7f6a',
    fontSize: 10,
    fontWeight: '600',
    minWidth: 40,
    textAlign: 'center',
  },
  // Statistics Styles
  statsContainer: {
    padding: 16,
  },
  statsHeader: {
    marginBottom: 24,
    alignItems: 'center',
  },
  statsTitle: {
    color: '#e9ddc4',
    fontSize: 20,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 8,
  },
  statsSubtitle: {
    color: '#8a7f6a',
    fontSize: 14,
    textAlign: 'center',
  },
  emptyStatsContainer: {
    alignItems: 'center',
    paddingVertical: 48,
  },
  emptyStatsText: {
    color: '#8a7f6a',
    fontSize: 16,
    textAlign: 'center',
    marginTop: 16,
  },
  questionStatCard: {
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  questionStatHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  questionStatNumber: {
    color: '#00ffc8',
    fontSize: 16,
    fontWeight: 'bold',
  },
  questionStatAccuracy: {
    alignItems: 'center',
  },
  accuracyText: {
    color: '#e9ddc4',
    fontSize: 18,
    fontWeight: 'bold',
  },
  accuracyLabel: {
    color: '#8a7f6a',
    fontSize: 12,
  },
  questionStatText: {
    color: '#e9ddc4',
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 16,
  },
  questionStatDetails: {
    marginBottom: 12,
  },
  statRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  statLabel: {
    color: '#8a7f6a',
    fontSize: 12,
    fontWeight: '600',
  },
  statValue: {
    color: '#e9ddc4',
    fontSize: 12,
    fontWeight: 'bold',
  },
  accuracyBar: {
    height: 6,
    backgroundColor: '#3a3a5e',
    borderRadius: 3,
    overflow: 'hidden',
  },
  accuracyBarFill: {
    height: '100%',
    backgroundColor: '#00ffc8',
    borderRadius: 3,
  },
  // Date Filter Styles
  dateFilterContainer: {
    padding: 16,
  },
  filterTypeContainer: {
    marginBottom: 20,
  },
  filterTypeTitle: {
    color: '#e9ddc4',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
    textAlign: 'center',
  },
  filterTypeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1a1a2e',
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  filterTypeButtonActive: {
    backgroundColor: '#00ffc8',
    borderColor: '#00ffc8',
  },
  filterTypeText: {
    color: '#00ffc8',
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 12,
  },
  filterTypeTextActive: {
    color: '#1a1a2e',
  },
  customDateContainer: {
    marginBottom: 20,
    alignItems: 'center',
  },
  customDateTitle: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  // Date Picker Styles
  datePickerContainer: {
    padding: 16,
    alignItems: 'center',
  },
  datePickerLabel: {
    color: '#e9ddc4',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  dateInput: {
    backgroundColor: '#0f0f1f',
    borderRadius: 8,
    padding: 12,
    color: '#e9ddc4',
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#3a3a5e',
    marginBottom: 20,
  },
  datePickerButtons: {
    flexDirection: 'row',
    gap: 12,
    width: '100%',
    maxWidth: 280,
  },
  datePickerButton: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    backgroundColor: '#3a3a5e',
    alignItems: 'center',
  },
  datePickerButtonPrimary: {
    backgroundColor: '#00ffc8',
  },
  datePickerButtonText: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: 'bold',
  },
  datePickerButtonTextPrimary: {
    color: '#1a1a2e',
  },
  // Calendar Styles
  calendarContainer: {
    backgroundColor: '#1a1a2e',
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
    maxWidth: 280,
    alignSelf: 'center',
  },
  calendarHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  calendarNavButton: {
    padding: 6,
    borderRadius: 6,
    backgroundColor: 'rgba(0, 255, 200, 0.1)',
  },
  calendarMonthYear: {
    color: '#e9ddc4',
    fontSize: 16,
    fontWeight: 'bold',
  },
  calendarDayNames: {
    flexDirection: 'row',
    marginBottom: 6,
  },
  calendarDayName: {
    flex: 1,
    textAlign: 'center',
    color: '#8a7f6a',
    fontSize: 10,
    fontWeight: 'bold',
    paddingVertical: 4,
  },
  calendarDays: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  calendarDay: {
    width: `${100/7}%`,
    aspectRatio: 1,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 6,
    margin: 1,
  },
  calendarDayEmpty: {
    width: `${100/7}%`,
    aspectRatio: 1,
    margin: 1,
  },
  calendarDaySelected: {
    backgroundColor: '#00ffc8',
  },
  calendarDayToday: {
    backgroundColor: 'rgba(0, 255, 200, 0.2)',
    borderWidth: 1,
    borderColor: '#00ffc8',
  },
  calendarDayText: {
    color: '#e9ddc4',
    fontSize: 12,
    fontWeight: '500',
  },
  calendarDayTextSelected: {
    color: '#1a1a2e',
    fontWeight: 'bold',
  },
  calendarDayTextToday: {
    color: '#00ffc8',
    fontWeight: 'bold',
  },
  // Dashboard Styles
  dashboardOverview: {
    flexDirection: 'row',
    marginBottom: 24,
    gap: 12,
  },
  overviewCard: {
    flex: 1,
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  overviewNumber: {
    color: '#e9ddc4',
    fontSize: 24,
    fontWeight: 'bold',
    marginVertical: 8,
  },
  overviewLabel: {
    color: '#8a7f6a',
    fontSize: 12,
    textAlign: 'center',
  },
  dashboardSection: {
    marginBottom: 20,
  },
  dashboardSectionTitle: {
    color: '#e9ddc4',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
    flexDirection: 'row',
    alignItems: 'center',
  },
  dashboardSectionSubtitle: {
    color: '#8a7f6a',
    fontSize: 14,
    marginBottom: 16,
  },
  dashboardQuestionCard: {
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  questionCardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  questionNumberBadge: {
    backgroundColor: '#00ffc8',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  questionNumberText: {
    color: '#1a1a2e',
    fontSize: 12,
    fontWeight: 'bold',
  },
  questionAccuracyBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 8,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  questionAccuracyText: {
    fontSize: 12,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  questionCardText: {
    color: '#e9ddc4',
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 12,
  },
  questionCardStats: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 12,
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statItemText: {
    color: '#8a7f6a',
    fontSize: 12,
    marginLeft: 4,
  },
  questionProgressContainer: {
    marginBottom: 8,
  },
  questionProgressBar: {
    height: 6,
    backgroundColor: '#3a3a5e',
    borderRadius: 3,
    overflow: 'hidden',
    marginBottom: 4,
  },
  questionProgressFill: {
    height: '100%',
    borderRadius: 3,
  },
  questionProgressText: {
    color: '#8a7f6a',
    fontSize: 10,
    textAlign: 'right',
  },
  wrongAnswerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 193, 7, 0.1)',
    borderRadius: 6,
    padding: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 193, 7, 0.3)',
  },
  wrongAnswerText: {
    color: '#8a7f6a',
    fontSize: 11,
    marginLeft: 6,
    flex: 1,
  },
  wrongAnswerValue: {
    color: '#ffc107',
    fontWeight: 'bold',
  },
  performanceChart: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'flex-end',
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#3a3a5e',
    height: 120,
  },
  chartBar: {
    alignItems: 'center',
    flex: 1,
  },
  chartBarContainer: {
    height: 80,
    width: 20,
    backgroundColor: '#3a3a5e',
    borderRadius: 10,
    overflow: 'hidden',
    marginBottom: 8,
    justifyContent: 'flex-end',
  },
  chartBarFill: {
    width: '100%',
    borderRadius: 10,
  },
  chartBarLabel: {
    color: '#8a7f6a',
    fontSize: 10,
    fontWeight: 'bold',
  },
  chartBarValue: {
    color: '#e9ddc4',
    fontSize: 10,
    fontWeight: 'bold',
    marginTop: 2,
  },
  // Combined view styles
  combinedSection: {
    marginBottom: 20,
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  combinedSectionTitle: {
    color: '#00ffc8',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
    textAlign: 'center',
  },
  testScoresContainer: {
    gap: 12,
  },
  testScoreItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#2a2a3e',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  testScoreLabel: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: '600',
    flex: 1,
  },
  testScoreValue: {
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 12,
  },
  checklistResultsContainer: {
    gap: 8,
  },
  checklistResultItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#2a2a3e',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  checklistResultInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  checklistResultLabel: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: '600',
    marginRight: 8,
  },
  checklistResultValue: {
    fontSize: 14,
    fontWeight: 'bold',
  },
  viewDetailsButton: {
    backgroundColor: 'rgba(0, 255, 200, 0.2)',
    borderRadius: 6,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.4)',
  },
  viewDetailsButtonText: {
    color: '#00ffc8',
    fontSize: 12,
    fontWeight: '600',
  },
  // Unified view styles
  testSection: {
    marginBottom: 20,
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  testHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#3a3a5e',
  },
  testTitle: {
    color: '#00ffc8',
    fontSize: 18,
    fontWeight: 'bold',
  },
  testScore: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: '600',
  },
  questionsContainer: {
    gap: 16,
  },
  questionCard: {
    backgroundColor: '#2a2a3e',
    borderRadius: 8,
    padding: 16,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  questionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  questionNumber: {
    color: '#00ffc8',
    fontSize: 14,
    fontWeight: 'bold',
  },
  answerStatus: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  answerStatusText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  questionText: {
    color: '#e9ddc4',
    fontSize: 16,
    lineHeight: 22,
    marginBottom: 12,
  },
  choicesContainer: {
    gap: 8,
  },
  choiceContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 6,
    borderWidth: 1,
    borderColor: '#3a3a5e',
    backgroundColor: '#1a1a2e',
  },
  userAnswerChoice: {
    borderColor: '#ffc107',
    backgroundColor: 'rgba(255, 193, 7, 0.1)',
  },
  correctAnswerChoice: {
    borderColor: '#28a745',
    backgroundColor: 'rgba(40, 167, 69, 0.1)',
  },
  choiceLetter: {
    color: '#8a7f6a',
    fontSize: 14,
    fontWeight: 'bold',
    marginRight: 12,
    minWidth: 20,
  },
  choiceText: {
    color: '#e9ddc4',
    fontSize: 14,
    flex: 1,
  },
  userAnswerText: {
    color: '#ffc107',
    fontWeight: 'bold',
  },
  correctAnswerText: {
    color: '#28a745',
    fontWeight: 'bold',
  },
  checklistSection: {
    marginBottom: 20,
    backgroundColor: '#1a1a2e',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  checklistHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
    paddingBottom: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#3a3a5e',
  },
  checklistTitle: {
    color: '#00ffc8',
    fontSize: 16,
    fontWeight: 'bold',
  },
  checklistStatus: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  checklistStatusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  checklistInfo: {
    marginBottom: 12,
  },
  checklistScore: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 4,
  },
  checklistComments: {
    color: '#8a7f6a',
    fontSize: 12,
    fontStyle: 'italic',
  },
  checklistSteps: {
    marginTop: 8,
  },
  statusContainer: {
    gap: 12,
  },
  statusItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#2a2a3e',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  statusLabel: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: '600',
  },
  statusValue: {
    fontSize: 14,
    fontWeight: 'bold',
  },
  // Simple combined view styles
  simpleRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    backgroundColor: '#2a2a3e',
    borderRadius: 6,
    marginBottom: 6,
    borderWidth: 1,
    borderColor: '#3a3a5e',
  },
  simpleLabel: {
    color: '#e9ddc4',
    fontSize: 14,
    fontWeight: '600',
  },
  simpleValue: {
    fontSize: 14,
    fontWeight: 'bold',
  },
  // Certificate Button Styles
  certificateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 6,
    paddingHorizontal: 8,
    borderRadius: 6,
    minWidth: 60,
    gap: 4,
  },
  certificateButtonText: {
    color: '#ffffff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  // Crystal Mirror Dashboard Styles
  dashboardContainer: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  modernHeader: {
    paddingHorizontal: 20,
    paddingVertical: 24,
    marginBottom: 24,
  },
  headerContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  logoContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  logoIcon: {
    width: 48,
    height: 48,
    borderRadius: 12,
    backgroundColor: 'rgba(147, 197, 253, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  modernTitle: {
    fontSize: 24,
    fontWeight: '700',
    color: '#FFFFFF',
    letterSpacing: -0.5,
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 10,
  },
  headerActions: {
    flexDirection: 'row',
    gap: 8,
  },
  headerButton: {
    width: 40,
    height: 40,
    borderRadius: 10,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 4,
  },
  modernSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '400',
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
  },
  emptyIconContainer: {
    width: 80,
    height: 80,
    borderRadius: 20,
    backgroundColor: 'rgba(147, 197, 253, 0.15)',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 12,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#FFFFFF',
    marginBottom: 8,
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  emptyDescription: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.7)',
    textAlign: 'center',
    lineHeight: 20,
  },
  modernContent: {
    paddingHorizontal: 20,
  },
  metricsRow: {
    flexDirection: 'row',
    gap: 16,
    marginBottom: 32,
  },
  metricCard: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    borderRadius: 20,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.2)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.2,
    shadowRadius: 16,
    elevation: 12,
  },
  metricIconContainer: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: 'rgba(147, 197, 253, 0.15)',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  metricValue: {
    fontSize: 28,
    fontWeight: '700',
    color: '#FFFFFF',
    marginBottom: 4,
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  metricLabel: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '500',
    marginBottom: 8,
  },
  metricTrend: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  trendText: {
    fontSize: 12,
    color: '#34D399',
    fontWeight: '600',
    textShadowColor: 'rgba(52, 211, 153, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  primaryCard: {
    backgroundColor: 'rgba(147, 197, 253, 0.1)',
    borderColor: 'rgba(147, 197, 253, 0.3)',
    shadowColor: '#93C5FD',
  },
  secondaryCard: {
    backgroundColor: 'rgba(251, 191, 36, 0.1)',
    borderColor: 'rgba(251, 191, 36, 0.3)',
    shadowColor: '#FBBF24',
  },
  successCard: {
    backgroundColor: 'rgba(52, 211, 153, 0.1)',
    borderColor: 'rgba(52, 211, 153, 0.3)',
    shadowColor: '#34D399',
  },
  warningCard: {
    backgroundColor: 'rgba(96, 165, 250, 0.1)',
    borderColor: 'rgba(96, 165, 250, 0.3)',
    shadowColor: '#60A5FA',
  },
  overviewSection: {
    marginBottom: 32,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  sectionActions: {
    flexDirection: 'row',
    gap: 8,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
    paddingHorizontal: 12,
    paddingVertical: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 8,
  },
  actionButtonText: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.8)',
    fontWeight: '500',
  },
  overviewCards: {
    flexDirection: 'row',
    gap: 16,
  },
  overviewCard: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    borderRadius: 20,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.2)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.2,
    shadowRadius: 16,
    elevation: 12,
  },
  overviewHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  overviewTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  statusIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    shadowColor: '#34D399',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.6,
    shadowRadius: 4,
    elevation: 4,
  },
  statusText: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '500',
  },
  overviewStats: {
    gap: 12,
  },
  overviewStat: {
    gap: 4,
  },
  overviewValue: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.6)',
    fontWeight: '500',
  },
  overviewNumber: {
    fontSize: 16,
    color: '#FFFFFF',
    fontWeight: '600',
    textShadowColor: 'rgba(147, 197, 253, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  overviewSubtext: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.5)',
  },
  certificationStats: {
    gap: 12,
  },
  certificationItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  certificationLabel: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.6)',
    fontWeight: '500',
  },
  certificationValue: {
    fontSize: 16,
    color: '#FFFFFF',
    fontWeight: '600',
    textShadowColor: 'rgba(147, 197, 253, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  // Professional Charts Section
  chartsSection: {
    marginBottom: 32,
  },
  chartsRow: {
    flexDirection: 'row',
    gap: 16,
    marginBottom: 20,
  },
  chartContainer: {
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    borderRadius: 20,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.2)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.2,
    shadowRadius: 16,
    elevation: 12,
    marginBottom: 20,
  },
  chartHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  chartTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  chartActions: {
    flexDirection: 'row',
    gap: 8,
  },
  chartActionButton: {
    width: 32,
    height: 32,
    borderRadius: 8,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
  },
  
  // Donut Chart Styles
  donutChartContainer: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    borderRadius: 20,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.2)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.2,
    shadowRadius: 16,
    elevation: 12,
  },
  donutChartHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  donutChartTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  donutChartActions: {
    flexDirection: 'row',
    gap: 4,
  },
  donutChartWrapper: {
    alignItems: 'center',
    marginBottom: 16,
  },
  donutChart: {
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    borderWidth: 2,
    borderColor: 'rgba(147, 197, 253, 0.3)',
  },
  donutChartInner: {
    alignItems: 'center',
    zIndex: 2,
  },
  donutChartPercentage: {
    fontSize: 24,
    fontWeight: '700',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  donutChartLabel: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '500',
  },
  donutChartRing: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 8,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  donutChartSegment: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 8,
    borderColor: 'transparent',
    borderTopColor: 'currentColor',
    transformOrigin: 'center',
  },
  donutChartStats: {
    gap: 8,
  },
  donutStatItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  donutStatDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 4,
  },
  donutStatText: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '500',
  },
  
  // Area Chart Styles
  areaChartContainer: {
    height: 200,
    flexDirection: 'row',
  },
  areaChartYAxis: {
    width: 40,
    justifyContent: 'space-between',
    paddingVertical: 10,
  },
  areaChartYLabel: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.5)',
    fontWeight: '500',
    textAlign: 'right',
  },
  areaChartContent: {
    flex: 1,
    position: 'relative',
  },
  areaChartGrid: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
  },
  areaChartGridLine: {
    width: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  areaChartArea: {
    flex: 1,
    position: 'relative',
    marginTop: 10,
    marginBottom: 30,
  },
  areaChartPath: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  areaChartFill: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(147, 197, 253, 0.2)',
    borderTopLeftRadius: 8,
    borderTopRightRadius: 8,
  },
  areaChartLine: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderTopWidth: 2,
    borderTopColor: '#93C5FD',
    borderTopLeftRadius: 8,
    borderTopRightRadius: 8,
  },
  areaChartDots: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  areaChartDot: {
    position: 'absolute',
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#93C5FD',
    borderWidth: 2,
    borderColor: '#FFFFFF',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.5,
    shadowRadius: 4,
    elevation: 8,
  },
  areaChartXAxis: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    marginTop: 10,
  },
  areaChartXLabel: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '500',
    textAlign: 'center',
  },
  
  // Gauge Chart Styles
  gaugeChartContainer: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    borderRadius: 20,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.2)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.2,
    shadowRadius: 16,
    elevation: 12,
  },
  gaugeChartHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  gaugeChartTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  gaugeChartWrapper: {
    alignItems: 'center',
    marginBottom: 16,
  },
  gaugeChart: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    borderWidth: 2,
    borderColor: 'rgba(147, 197, 253, 0.3)',
  },
  gaugeChartArc: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: 100,
    height: 100,
    borderRadius: 50,
    borderWidth: 6,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    borderTopColor: 'transparent',
    borderRightColor: 'transparent',
  },
  gaugeChartFill: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: 100,
    height: 100,
    borderRadius: 50,
    borderWidth: 6,
    borderColor: 'transparent',
    borderTopColor: 'currentColor',
    transformOrigin: 'center',
  },
  gaugeChartCenter: {
    alignItems: 'center',
    zIndex: 2,
  },
  gaugeChartValue: {
    fontSize: 20,
    fontWeight: '700',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 6,
  },
  gaugeChartLabel: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '500',
  },
  gaugeChartLegend: {
    gap: 6,
  },
  gaugeLegendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  gaugeLegendDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    elevation: 2,
  },
  gaugeLegendText: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.7)',
    fontWeight: '500',
  },
  
  // Clickable Card Styles
  clickableCard: {
    position: 'relative',
  },
  clickIndicator: {
    position: 'absolute',
    top: 12,
    right: 12,
    opacity: 0.7,
  },
  
  // Participant Modal Styles
  participantModalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  participantModalContent: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#1a1a2e',
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 16,
  },
  participantModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(147, 197, 253, 0.2)',
  },
  participantModalTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#FFFFFF',
    textShadowColor: 'rgba(147, 197, 253, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 8,
  },
  participantModalCloseButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.3)',
  },
  participantModalBody: {
    maxHeight: '70%',
  },
  participantEmptyState: {
    alignItems: 'center',
    paddingVertical: 40,
  },
  participantEmptyText: {
    fontSize: 16,
    color: 'rgba(255, 255, 255, 0.7)',
    marginTop: 12,
  },
  participantItem: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 12,
    padding: 16,
    margin: 8,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.2)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  participantItemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  participantItemInfo: {
    flex: 1,
  },
  participantItemName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
    marginBottom: 4,
    textShadowColor: 'rgba(147, 197, 253, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 4,
  },
  participantItemId: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  participantItemStats: {
    alignItems: 'flex-end',
    gap: 4,
  },
  participantStatItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  participantStatLabel: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.6)',
    fontWeight: '500',
  },
  participantStatValue: {
    fontSize: 12,
    fontWeight: '600',
    minWidth: 30,
    textAlign: 'right',
  },
  participantItemFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  participantItemDate: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.6)',
  },
  participantItemStatus: {
    flexDirection: 'row',
    gap: 8,
  },
  participantStatusBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    gap: 4,
  },
  participantStatusText: {
    fontSize: 10,
    color: '#FFFFFF',
    fontWeight: '500',
  },

  // Futuristic Dashboard Styles
  futuristicDashboardContainer: {
    flex: 1,
    backgroundColor: '#0a0a0a',
  },
  futuristicHeader: {
    position: 'relative',
    padding: 20,
    backgroundColor: 'rgba(0, 255, 200, 0.05)',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 255, 200, 0.2)',
  },
  headerGlow: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 2,
    backgroundColor: '#00ffc8',
    shadowColor: '#00ffc8',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.8,
    shadowRadius: 10,
    elevation: 10,
  },
  futuristicTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#00ffc8',
    textShadowColor: 'rgba(0, 255, 200, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 10,
  },
  futuristicSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.7)',
    marginTop: 5,
  },
  futuristicButton: {
    padding: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(0, 255, 200, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.3)',
  },
  futuristicContent: {
    padding: 20,
  },

  // Highest Scores Section
  highestScoresSection: {
    marginBottom: 30,
  },
  futuristicSectionTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#00ffc8',
    marginBottom: 15,
    textShadowColor: 'rgba(0, 255, 200, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 5,
  },
  sectionGlow: {
    position: 'absolute',
    bottom: -5,
    left: 0,
    width: 50,
    height: 2,
    backgroundColor: '#00ffc8',
    shadowColor: '#00ffc8',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.8,
    shadowRadius: 5,
  },
  scoresGrid: {
    flexDirection: 'row',
    gap: 15,
  },
  scoreCard: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 15,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.2)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  scoreCardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
    gap: 10,
  },
  scoreCardTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  scoreValues: {
    gap: 10,
  },
  scoreItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  scoreLabel: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  scoreValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#00ffc8',
  },

  // Pass/Fail Section
  passFailSection: {
    marginBottom: 30,
  },
  chartsGrid: {
    flexDirection: 'row',
    gap: 15,
  },
  modernChartCard: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 15,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.2)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  chartHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  chartTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  chartBadge: {
    backgroundColor: 'rgba(0, 255, 200, 0.2)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  chartBadgeText: {
    fontSize: 10,
    fontWeight: 'bold',
    color: '#00ffc8',
  },
  donutChartContainer: {
    alignItems: 'center',
    marginBottom: 15,
  },
  donutChart: {
    width: 120,
    height: 120,
    position: 'relative',
    alignItems: 'center',
    justifyContent: 'center',
  },
  donutChartInner: {
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 2,
  },
  donutPercentage: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  donutLabel: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  donutRing: {
    position: 'absolute',
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 8,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  donutSegment: {
    position: 'absolute',
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 8,
    borderColor: 'transparent',
    borderTopColor: '#00ffc8',
    transformOrigin: 'center',
  },
  chartLegend: {
    gap: 8,
  },
  legendItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  legendDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  legendText: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.8)',
  },

  // Question Analysis Section
  questionAnalysisSection: {
    marginBottom: 30,
  },
  questionsList: {
    gap: 15,
  },
  questionCard: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 15,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.2)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 4,
  },
  questionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  questionNumber: {
    backgroundColor: 'rgba(0, 255, 200, 0.2)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  questionNumberText: {
    fontSize: 12,
    fontWeight: 'bold',
    color: '#00ffc8',
  },
  questionAccuracy: {
    alignItems: 'center',
  },
  accuracyText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ff6b6b',
  },
  accuracyLabel: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  questionText: {
    fontSize: 14,
    color: '#FFFFFF',
    lineHeight: 20,
    marginBottom: 15,
  },
  questionStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 15,
  },
  statItem: {
    alignItems: 'center',
  },
  statLabel: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.6)',
    marginBottom: 4,
  },
  statValue: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  suggestionBox: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 217, 61, 0.1)',
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: 'rgba(255, 217, 61, 0.3)',
    gap: 8,
  },
  suggestionText: {
    fontSize: 12,
    color: '#ffd93d',
    flex: 1,
    lineHeight: 16,
  },

  // Futuristic Stats Container Styles
  futuristicStatsContainer: {
    flex: 1,
    backgroundColor: '#0a0a0a',
  },
  futuristicStatsHeader: {
    position: 'relative',
    padding: 20,
    backgroundColor: 'rgba(0, 255, 200, 0.05)',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 255, 200, 0.2)',
  },
  statsHeaderGlow: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 2,
    backgroundColor: '#00ffc8',
    shadowColor: '#00ffc8',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.8,
    shadowRadius: 10,
    elevation: 10,
  },
  statsHeaderContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  statsLogoContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 15,
  },
  futuristicStatsTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#00ffc8',
    textShadowColor: 'rgba(0, 255, 200, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 10,
  },
  futuristicStatsSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.7)',
    marginTop: 5,
  },
  futuristicStatsContent: {
    padding: 20,
  },

  // Clickable score card styles
  clickHint: {
    fontSize: 10,
    color: 'rgba(255, 255, 255, 0.6)',
    textAlign: 'center',
    marginTop: 8,
    fontStyle: 'italic',
  },

  // Answer choices styles
  answerChoicesContainer: {
    marginVertical: 15,
    padding: 15,
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    borderRadius: 10,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.1)',
  },
  answerChoicesTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#00ffc8',
    marginBottom: 10,
  },
  answerChoicesList: {
    gap: 12,
  },
  answerChoiceRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 12,
  },
  answerChoiceBadge: {
    width: 32,
    height: 32,
    borderRadius: 16,
    borderWidth: 2,
    alignItems: 'center',
    justifyContent: 'center',
    flexShrink: 0,
  },
  answerChoiceLetter: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  answerChoiceContent: {
    flex: 1,
  },
  answerChoiceText: {
    fontSize: 13,
    color: '#FFFFFF',
    lineHeight: 18,
    marginBottom: 4,
  },
  answerChoiceStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  answerChoiceCount: {
    fontSize: 11,
    color: 'rgba(255, 255, 255, 0.7)',
  },
  answerChoiceLabel: {
    fontSize: 11,
    fontWeight: 'bold',
  },

  // Date filter modal styles
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#1a1a1a',
    borderRadius: 15,
    padding: 20,
    width: '90%',
    maxWidth: 400,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.3)',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0, 255, 200, 0.2)',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  modalCloseButton: {
    padding: 5,
  },
  dateFilterOptions: {
    gap: 12,
  },
  dateFilterOption: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    borderRadius: 10,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.2)',
  },
  dateFilterOptionActive: {
    backgroundColor: 'rgba(0, 255, 200, 0.1)',
    borderColor: '#00ffc8',
  },
  dateFilterOptionText: {
    fontSize: 16,
    color: '#FFFFFF',
    marginLeft: 12,
    fontWeight: '500',
  },

  // Highest Scorers Modal Styles
  highestScoreText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#00ffc8',
    textAlign: 'center',
    marginBottom: 20,
  },
  scorersList: {
    gap: 12,
  },
  scorerItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 10,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.2)',
  },
  scorerRank: {
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: '#00ffc8',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 15,
  },
  scorerRankText: {
    color: '#1a1a1a',
    fontSize: 16,
    fontWeight: 'bold',
  },
  scorerDetails: {
    flex: 1,
  },
  scorerName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 4,
  },
  scorerPosition: {
    fontSize: 14,
    color: '#8a7f6a',
    marginBottom: 2,
  },
  scorerDate: {
    fontSize: 12,
    color: '#8a7f6a',
  },
  scorerScore: {
    backgroundColor: 'rgba(0, 255, 200, 0.1)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 15,
    borderWidth: 1,
    borderColor: '#00ffc8',
  },
  scorerScoreText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#00ffc8',
  },
  modalFooter: {
    marginTop: 20,
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 255, 200, 0.2)',
  },
  modalButton: {
    backgroundColor: '#00ffc8',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignItems: 'center',
  },
  modalButtonText: {
    color: '#1a1a1a',
    fontSize: 16,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 5,
  },

  // Top 3 Ranking Styles
  firstPlace: {
    borderColor: '#FFD700',
    backgroundColor: 'rgba(255, 215, 0, 0.1)',
    borderWidth: 2,
  },
  secondPlace: {
    borderColor: '#C0C0C0',
    backgroundColor: 'rgba(192, 192, 192, 0.1)',
    borderWidth: 2,
  },
  thirdPlace: {
    borderColor: '#CD7F32',
    backgroundColor: 'rgba(205, 127, 50, 0.1)',
    borderWidth: 2,
  },
  firstPlaceRank: {
    backgroundColor: '#FFD700',
    width: 40,
    height: 40,
    borderRadius: 20,
  },
  secondPlaceRank: {
    backgroundColor: '#C0C0C0',
    width: 40,
    height: 40,
    borderRadius: 20,
  },
  thirdPlaceRank: {
    backgroundColor: '#CD7F32',
    width: 40,
    height: 40,
    borderRadius: 20,
  },
  firstPlaceRankText: {
    color: '#1a1a1a',
    fontSize: 20,
  },
  secondPlaceRankText: {
    color: '#1a1a1a',
    fontSize: 18,
  },
  thirdPlaceRankText: {
    color: '#1a1a1a',
    fontSize: 16,
  },
  firstPlaceName: {
    color: '#FFD700',
    fontSize: 18,
    fontWeight: 'bold',
  },
  firstPlaceScore: {
    backgroundColor: 'rgba(255, 215, 0, 0.2)',
    borderColor: '#FFD700',
  },
  secondPlaceScore: {
    backgroundColor: 'rgba(192, 192, 192, 0.2)',
    borderColor: '#C0C0C0',
  },
  thirdPlaceScore: {
    backgroundColor: 'rgba(205, 127, 50, 0.2)',
    borderColor: '#CD7F32',
  },
  firstPlaceScoreText: {
    color: '#FFD700',
    fontSize: 18,
    fontWeight: 'bold',
  },
  secondPlaceScoreText: {
    color: '#C0C0C0',
    fontSize: 16,
    fontWeight: 'bold',
  },
  thirdPlaceScoreText: {
    color: '#CD7F32',
    fontSize: 16,
    fontWeight: 'bold',
  },

  // Enhanced Dashboard Statistics Styles
  testStatsContainer: {
    marginBottom: 20,
  },
  testTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 12,
    textAlign: 'center',
  },
  statsRow: {
    flexDirection: 'row',
    gap: 12,
  },
  statCard: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.08)',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: 'rgba(147, 197, 253, 0.2)',
    shadowColor: '#93C5FD',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  passCard: {
    borderColor: 'rgba(16, 185, 129, 0.3)',
    backgroundColor: 'rgba(16, 185, 129, 0.05)',
  },
  failCard: {
    borderColor: 'rgba(239, 68, 68, 0.3)',
    backgroundColor: 'rgba(239, 68, 68, 0.05)',
  },
  statHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    gap: 6,
  },
  statLabel: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.8)',
    fontWeight: '500',
  },
  statNumber: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
    marginBottom: 4,
  },
  statPercentage: {
    fontSize: 14,
    fontWeight: '600',
    color: 'rgba(255, 255, 255, 0.7)',
    textAlign: 'center',
  },

  // Date Filter Status Styles
  dateFilterStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 255, 200, 0.1)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: 'rgba(0, 255, 200, 0.2)',
    gap: 8,
  },
  dateFilterStatusText: {
    fontSize: 14,
    color: '#00ffc8',
    fontWeight: '500',
    flex: 1,
  },

  // No Data Styles
  noDataContainer: {
    alignItems: 'center',
    paddingVertical: 40,
    paddingHorizontal: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 12,
    marginVertical: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  noDataTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginTop: 16,
    marginBottom: 8,
  },
  noDataDescription: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.7)',
    textAlign: 'center',
    lineHeight: 20,
  },
});